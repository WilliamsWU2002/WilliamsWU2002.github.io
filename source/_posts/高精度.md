---
title: 高精度
date: 2018-03-01 21:50:28
tags: 基础算法
---

>关键词: 高精度 

<!--more-->
### 高精度这种基础知识还是需要复习一下的，所以干脆来总结一下
#### 1.高精度加法 
就是模拟竖式，处理一下进位就好了，需要注意读入的时候用scanf()比较保险，别乱用gets，还有就是加完前导零需要处理。 
 
```cpp
头文件省略
//另一种写法
/*
char as[11001],bs[11001];
int a[11001],b[11001],c[11002];
int la,lb,lc;
int main()
{
	cle(a); cle(b); cle(c);
	scanf("%s%s",as,bs);
	la=strlen(as);
	lb=strlen(bs);
	rep_(i,0,la)  a[i+1]=as[i]-'0';
	rep_(i,0,lb)  b[i+1]=bs[i]-'0';
	rep(i,1,la/2)  swap(a[i],a[la-i+1]);
	rep(i,1,lb/2)  swap(b[i],b[lb-i+1]);
	if(la>lb)  lc=la;
		else lc=lb;
	rep(i,1,lc)
	{
		c[i]=c[i]+a[i]+b[i];
		c[i+1]=c[i]/10;
		c[i]=c[i]%10;
	}
	if(c[lc+1]>0)  lc+=1;
	repf(i,lc,1)  printf("%d",c[i]);
	cout<<endl;
	return 0;
}
*/

char as[1100],bs[1100];
int a[1100],b[1100],c[1100],la,lb,lc,x;
int main()
{
    cle(a); cle(b); cle(c);
    scanf("%s%s",as,bs); //用字符串读入两个加数  warning!!! 别用gets 会莫名爆错
    la=strlen(as); //求长度
    lb=strlen(bs); 
    rep_(i,0,la)  a[la-i]=as[i]-'0';  //倒序储存
    rep_(i,0,lb)  b[lb-i]=bs[i]-'0';
    lc=1; x=0;
    while(lc<=la||lc<=lb) //相当于取两个加数中位数多的那一个
    {
        c[lc]=a[lc]+b[lc]+x; //当前位两数相加再加上上一位的进位
        x=c[lc]/10; //处理当前位的进位
        c[lc]%=10; 
        lc++; //下一位
    }
    c[lc]=x; //最后一次进位即为第一位
    if(c[lc]==0)  lc--; //处理前导零
    repf(i,lc,1)  printf("%d",c[i]); //倒序输出
    cout<<endl;
    return 0;
}
```
#### 2.高精度减法
几乎和高精度加法一样，需要判一下减数与被减数的大小

```cpp
char n[1000],n1[1000],n2[1000];
int a[1000],b[1000],c[1000];
int la,lb,lc;
int main()
{
    cle(a); cle(b); cle(c);  //初始化
    scanf("%s%s",n1,n2);
    la=strlen(n1);
    lb=strlen(n2);
    if(la<lb||(la==lb&&strcmp(n1,n2)<0)) //strcmp为字符串比较函数 此处处理输出负数的情况
    {
        strcpy(n,n1);  //strcpy(a,b) 将b的内容覆盖到a上 此三句相当于交换
        strcpy(n1,n2);  
        strcpy(n2,n);
        swap(la,lb);
        cout<< "-";
    }
    rep(i,0,la-1)  a[la-i]=n1[i]-'0';
    rep(i,0,lb-1)  b[lb-i]=n2[i]-'0';
    int k=1;
    while(k<=la||k<=lb)
    {
        if(a[k]<b[k])
        {
            a[k]+=10;  //当前位向上一位借1
            a[k+1]--;
        }
        c[k]=a[k]-b[k];  //当前位减一减
        k++;  //处理下一位
    }
    lc=k;  //长度
    while((c[lc]==0)&&(lc>1)) lc--; //别忘了前导零
    repf(i,lc,1) printf("%d",c[i]);
    cout<<endl;
    return 0;
}
```
#### 3.高精度乘法
这个就要比前两个有难度了，因为竖式算乘法本身就模拟了第一个乘数乘以第二个乘数拆开来的各个位，而我们要做的就是倒序状态下模拟这个过程（其实把两个乘数都拆开了），简单地试一下后会发现乘积的i+j-1位即是第一个乘数第i位与第二个乘数第j位的乘积，然后就好了。

```cpp
char as[1100],bs[1100];
int a[1100],b[1100],c[1100];
int la,lb,lc,x;
int main()
{
    cle(a); cle(b); cle(c);
    scanf("%s%s",as,bs);	
    la=strlen(as);
    lb=strlen(bs);
    rep_(i,0,la) a[la-i]=as[i]-'0';
    rep_(i,0,lb) b[lb-i]=bs[i]-'0';
  	rep(i,1,la)
	{
	     x=0;
	     rep(j,1,lb) //处理乘数的每一位
	     {
		   c[i+j-1]=a[i]*b[j]+x+c[i+j-1];  //当前位相乘+进位+乘积已有位上的数
		   x=c[i+j-1]/10;
		   c[i+j-1]%=10;
	     }
	     c[i+lb]=x;  //进位
	}
	lc=la+lb;
	while(c[lc]==0&&lc>1)  lc--;  //删除前导0
	repf(i,lc,1)  printf("%d",c[i]);
	cout<<endl;
	return 0;
}
```
#### 4.高精度除法
坑先占着 这东西太烦 原来写的也找不到了 不写了
