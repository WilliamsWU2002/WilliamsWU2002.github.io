<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2018%2F08%2F20%2Ftest%2F</url>
    <content type="text"><![CDATA[关键词: test testIt’s just for test!$0 test lateX 0$]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[treap]]></title>
    <url>%2F2018%2F05%2F12%2Ftreap%2F</url>
    <content type="text"><![CDATA[关键词: treap Treap Treap是一个优先值域满足堆的性质的二叉搜索树 建树时随机给每个节点赋随机优先值 要求 节点的优先值域满足堆的性质 &amp;&amp;节点的值满足二叉搜索树的性质 小知识普及 二叉查找树(Binary Search Tree)或者是一棵空树，或者是具有下列性质的二叉树 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉查找树。 故中序遍历二叉搜索树即可得到有序序列 前序遍历 根左右 在本图即为ABDECF中序遍历 左根右 DBEAFC后序遍历 左右根 DEBFCA 时间复杂度分析 每个操作期望复杂度都为O(log n) 插入：由于期望树高h为log n 插入操作是将待插入点放入叶节点并不断按要求旋转 （跟维护堆一样，如果当前节点的优先级比根大就旋转，如果当前节点是根的左儿子就右旋如果当前节点是根的右儿子就左旋。） 故最多进行复杂度为O(1)的旋转操作h次 删除：同理插入 删除是把待删除节点转到叶节点上然后直接删除即可 （每次找到优先级最大的儿子，向与其相反的方向旋转） 故最多也是进行h次旋转操作 查找：由于treap是二叉搜索树 但是是随机化结构 故期望O(log n) 分离： 要把一个Treap按大小分成两个Treap，只要在需要分开的位置加一个虚拟节点，然后旋至根节点删除，左右两个子树就是得出的两个Treap。 而根据二叉搜索树的性质，这时左子树的所有节点都小于右子树的节点。 合并： 合并两棵平衡树的条件正好是上方分离操作的结果 要求其中第一棵树的所有节点都必须小于或等于第二棵树中的所有节点 所以操作过程也正好与分离相反 只需要加一个虚拟的根，把两棵树分别作为左右子树，然后删除根即可 查找排名第 k 的元素 在一棵二叉搜索树中，根节点的排名取决于其左子树的大小 而我们知道treap的子树还是treap 由于节点有重复 所以如果当前节点P满足P.left.size&lt;=k&lt;=P.left.size+P.weight 那么P就是排名第K的元素 若满足 k &lt; P.left.size + 1，则在左子树中查找排名第 k 的元素； 若满足 k &gt; P.left.size + P.weight，则在右子树中查找排名第 k-(P.left.size + P.weight)的元素。 排名 如果没有重复元素 那么此操作与查找排名第 k 的元素为严格的逆运算 cur为当前已知的比要求的元素小的元素个数 当前节点等于目标 排名为P.left.size + cur + 1 （有重复的排名取最小） 当前节点大于目标，在左子树中查找排名； 当前元素小于目标，更新 cur 为 cur + P.left.size+weight，在右子树中查找排名 基本动作 旋转左旋 (A节点) 获取根节点A的右儿子节点B 将节点B的父亲节点信息更新为f （双向） 将节点A的右儿子信息更新为节点B的左儿子D （双向） 将节点B的左儿子信息更改为节点A （双向） 代码1(有父亲节点域的)：12345678910111213141516171819void LTURN(int u) //左旋&#123; treap[treap[u].pre].r=treap[u].l; treap[treap[u].l].pre=treap[u].pre; //将u的父亲作为u的左儿子的父亲 int tmp=treap[treap[u].pre].pre; treap[u].l=treap[u].pre; treap[treap[u].pre].pre=u; //将u作为与u的父亲的父亲 treap[u].pre=tmp; //将原来根节点的上继节点赋给新的根节点（也就是要旋转的u） if(tmp!=0) //如果根节点的上继节点不为0 &#123; if(treap[u].value&lt;treap[tmp].value) treap[tmp].l=u; //将根节点赋为根节点的上继节点的左儿子 else treap[tmp].r=u; //（同上）右儿子 &#125; else //根节点的上继节点为0 &#123; root=u; //u为正式的根节点 //treap[root].pre=0; //正式把根节点的上继节点赋为0 &#125;&#125; 代码2(无父亲节点域的)：123456789void lturn(int &amp;k) //由于没有父亲域 所以不需要双向改动&#123; int tmp=treap[k].r; //tmp即为将来根 treap[k].r=treap[tmp].l; //改变目前根的右节点为将来根的左节点 treap[tmp].l=k; //改变将来根的左节点为目前根 treap[tmp].size=treap[k].size; //更新将来根的节点数 update(k); //更新目前根的节点数 k=tmp; //改变根&#125; 右旋 (A节点)操作为左旋的镜像 获取根节点A的左儿子节点B 将节点B的父亲节点信息更新为f （双向） 将节点A的左儿子信息更新为节点B的右儿子D （双向） 将节点B的右儿子信息更改为节点A （双向） 代码1：12345678910111213141516171819void RTURN(int u) //右旋 操作同左旋&#123; treap[treap[u].pre].l=treap[u].r; treap[treap[u].r].pre=treap[u].pre; int tmp=treap[treap[u].pre].pre; treap[u].r=treap[u].pre; treap[treap[u].pre].pre=u; treap[u].pre=tmp; if(tmp!=0) &#123; if(treap[u].value&lt;treap[tmp].value) treap[tmp].l=u; else treap[tmp].r=u; &#125; else &#123; root=u; //treap[root].pre=0; &#125;&#125; 123456789void rturn(int &amp;k) //同理左旋&#123; int tmp=treap[k].l; treap[k].l=treap[tmp].r; treap[tmp].r=k; treap[tmp].size=treap[k].size; update(k); k=tmp;&#125; 模板代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157//Williams Wustruct node&#123; int l,r,value,rnd,amount,size; //左右儿子 值 随机的优先值 //.amount为某个值多次出现的个数 用来代替重复的节点 //.size为以当前节点为根的子树大小 是查询排名的必备 在删除 旋转 插入时都会改变&#125;;node treap[100005];int n,size,root,ans;void update(int k)&#123; //更新结点信息 treap[k].size=treap[treap[k].l].size+treap[treap[k].r].size+treap[k].amount; //一个节点的路径数等于左右儿子路径数与节点数值重复次数之和&#125;void lturn(int &amp;k) //由于没有父亲域 所以不需要双向改动&#123; int tmp=treap[k].r; //tmp即为将来根 treap[k].r=treap[tmp].l; //改变目前根的右节点为将来根的左节点 treap[tmp].l=k; //改变将来根的左节点为目前根 treap[tmp].size=treap[k].size; //更新将来根的节点数 update(k); //更新目前根的节点数 k=tmp; //改变根&#125;void rturn(int &amp;k) //同理左旋&#123; int tmp=treap[k].l; treap[k].l=treap[tmp].r; treap[tmp].r=k; treap[tmp].size=treap[k].size; update(k); k=tmp;&#125;void insert(int &amp;k,int x)&#123; if(k==0) &#123; k=++size; treap[k].size=treap[k].amount=1; treap[k].value=x; treap[k].rnd=rand(); return; &#125; //插入叶子结点 treap[k].size++; //每经过一个节点，都要先使以它为根的子树的大小增加 1，再递归进入子树查找 if(treap[k].value==x) treap[k].amount++; else if(x&gt;treap[k].value) //应在根的右边 &#123; insert(treap[k].r,x); //继续用根节点的右儿子搜索 if(treap[treap[k].r].rnd&lt;treap[k].rnd) lturn(k); //维护完二叉搜索树的性质后开始维护堆的性质（旋转） &#125; else &#123; insert(treap[k].l,x); //左儿子 if(treap[treap[k].l].rnd&lt;treap[k].rnd)rturn(k); //右旋 &#125;&#125;void del(int &amp;k,int x)&#123; if(k==0) return; //已到叶子结点 可以删除 if(treap[k].value==x) &#123; if(treap[k].amount&gt;1) //如果该节点不止一个 重复数量减掉一个即可 &#123; treap[k].amount--; treap[k].size--; //子树大小减1 return; &#125; if(treap[k].l*treap[k].r==0) k=treap[k].l+treap[k].r; //如果左右节点中有任何一个是叶子结点 直接替换当前根 else if(treap[treap[k].l].rnd&lt;treap[treap[k].r].rnd) //左子树的随机值比右子树小 &#123; rturn(k); //右旋 del(k,x); //继续讨论 &#125; else //反之亦然 &#123; lturn(k); del(k,x); &#125; &#125; else if(x&gt;treap[k].value) &#123; treap[k].size--; //递归返回时要把所有的经过的节点的子树的大小减1。注意 删除前要保证待删除节点存在于树中 del(treap[k].r,x); &#125; else &#123; treap[k].size--; del(treap[k].l,x); &#125;&#125;int ranknum(int k,int x)&#123; if(k==0) return 0; if(treap[k].value==x) return treap[treap[k].l].size+1; //左子树全部比根小 else if(x&gt;treap[k].value) return treap[treap[k].l].size+treap[k].amount+ranknum(treap[k].r,x); //注意要加上重复的个数 else return ranknum(treap[k].l,x);&#125;int rerank(int k,int x)//根据二叉搜索树的性质 根节点的rank取决于其左子树的大小&#123; if(k==0) return 0; if(x&lt;=treap[treap[k].l].size) return rerank(treap[k].l,x); else if(x&gt;treap[treap[k].l].size+treap[k].amount) //注意当前节点可能有多个重复的 return rerank(treap[k].r,x-treap[treap[k].l].size-treap[k].amount); else return treap[k].value;&#125;void provalue(int k,int x) //注意定义 小于/不大于&#123; if(k==0)return; //当前节点为空节点 查找结束 最优节点ans即为所求 if(treap[k].value&lt;x) //当前元素小于目标 &#123; ans=k; //更新最优节点 provalue(treap[k].r,x); //并访问当前节点的右儿子 &#125; else provalue(treap[k].l,x); //不满足条件 访问当前节点的左儿子&#125;void nextvalue(int k,int x)&#123; if(k==0)return; if(treap[k].value&gt;x) &#123; ans=k; nextvalue(treap[k].l,x); &#125; else nextvalue(treap[k].r,x);&#125;int main()&#123; read(n); int opt,x; rep(i,1,n) &#123; read(opt,x); switch(opt) &#123; case 1:insert(root,x); break; //插入 case 2:del(root,x); break; //删除 case 3:printf("%d\n",ranknum(root,x)); break; //排名 case 4:printf("%d\n",rerank(root,x)); break; //排名反向 case 5:ans=0;provalue(root,x); printf("%d\n",treap[ans].value);break; //前驱（小于的max） case 6:ans=0;nextvalue(root,x); printf("%d\n",treap[ans].value);break; //后继（大于的min） &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>高级数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高精度]]></title>
    <url>%2F2018%2F03%2F01%2F%E9%AB%98%E7%B2%BE%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[关键词: 高精度 高精度总结 高精度这种基础知识还是需要复习一下的，所以干脆来总结一下 1.高精度加法就是模拟竖式，处理一下进位就好了，需要注意读入的时候用scanf()比较保险，别乱用gets，还有就是加完前导零需要处理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455头文件省略//另一种写法/*char as[11001],bs[11001];int a[11001],b[11001],c[11002];int la,lb,lc;int main()&#123; cle(a); cle(b); cle(c); scanf("%s%s",as,bs); la=strlen(as); lb=strlen(bs); rep_(i,0,la) a[i+1]=as[i]-'0'; rep_(i,0,lb) b[i+1]=bs[i]-'0'; rep(i,1,la/2) swap(a[i],a[la-i+1]); rep(i,1,lb/2) swap(b[i],b[lb-i+1]); if(la&gt;lb) lc=la; else lc=lb; rep(i,1,lc) &#123; c[i]=c[i]+a[i]+b[i]; c[i+1]=c[i]/10; c[i]=c[i]%10; &#125; if(c[lc+1]&gt;0) lc+=1; repf(i,lc,1) printf("%d",c[i]); cout&lt;&lt;endl; return 0;&#125;*/char as[1100],bs[1100];int a[1100],b[1100],c[1100],la,lb,lc,x;int main()&#123; cle(a); cle(b); cle(c); scanf("%s%s",as,bs); //用字符串读入两个加数 warning!!! 别用gets 会莫名爆错 la=strlen(as); //求长度 lb=strlen(bs); rep_(i,0,la) a[la-i]=as[i]-'0'; //倒序储存 rep_(i,0,lb) b[lb-i]=bs[i]-'0'; lc=1; x=0; while(lc&lt;=la||lc&lt;=lb) //相当于取两个加数中位数多的那一个 &#123; c[lc]=a[lc]+b[lc]+x; //当前位两数相加再加上上一位的进位 x=c[lc]/10; //处理当前位的进位 c[lc]%=10; lc++; //下一位 &#125; c[lc]=x; //最后一次进位即为第一位 if(c[lc]==0) lc--; //处理前导零 repf(i,lc,1) printf("%d",c[i]); //倒序输出 cout&lt;&lt;endl; return 0;&#125; 2.高精度减法几乎和高精度加法一样，需要判一下减数与被减数的大小 123456789101112131415161718192021222324252627282930313233343536char n[1000],n1[1000],n2[1000];int a[1000],b[1000],c[1000];int la,lb,lc;int main()&#123; cle(a); cle(b); cle(c); //初始化 scanf("%s%s",n1,n2); la=strlen(n1); lb=strlen(n2); if(la&lt;lb||(la==lb&amp;&amp;strcmp(n1,n2)&lt;0)) //strcmp为字符串比较函数 此处处理输出负数的情况 &#123; strcpy(n,n1); //strcpy(a,b) 将b的内容覆盖到a上 此三句相当于交换 strcpy(n1,n2); strcpy(n2,n); swap(la,lb); cout&lt;&lt; "-"; &#125; rep(i,0,la-1) a[la-i]=n1[i]-'0'; rep(i,0,lb-1) b[lb-i]=n2[i]-'0'; int k=1; while(k&lt;=la||k&lt;=lb) &#123; if(a[k]&lt;b[k]) &#123; a[k]+=10; //当前位向上一位借1 a[k+1]--; &#125; c[k]=a[k]-b[k]; //当前位减一减 k++; //处理下一位 &#125; lc=k; //长度 while((c[lc]==0)&amp;&amp;(lc&gt;1)) lc--; //别忘了前导零 repf(i,lc,1) printf("%d",c[i]); cout&lt;&lt;endl; return 0;&#125; 3.高精度乘法这个就要比前两个有难度了，因为竖式算乘法本身就模拟了第一个乘数乘以第二个乘数拆开来的各个位，而我们要做的就是倒序状态下模拟这个过程（其实把两个乘数都拆开了），简单地试一下后会发现乘积的i+j-1位即是第一个乘数第i位与第二个乘数第j位的乘积，然后就好了。 12345678910111213141516171819202122232425262728char as[1100],bs[1100];int a[1100],b[1100],c[1100];int la,lb,lc,x;int main()&#123; cle(a); cle(b); cle(c); scanf("%s%s",as,bs); la=strlen(as); lb=strlen(bs); rep_(i,0,la) a[la-i]=as[i]-'0'; rep_(i,0,lb) b[lb-i]=bs[i]-'0'; rep(i,1,la) &#123; x=0; rep(j,1,lb) //处理乘数的每一位 &#123; c[i+j-1]=a[i]*b[j]+x+c[i+j-1]; //当前位相乘+进位+乘积已有位上的数 x=c[i+j-1]/10; c[i+j-1]%=10; &#125; c[i+lb]=x; //进位 &#125; lc=la+lb; while(c[lc]==0&amp;&amp;lc&gt;1) lc--; //删除前导0 repf(i,lc,1) printf("%d",c[i]); cout&lt;&lt;endl; return 0;&#125; 4.高精度除法坑先占着 这东西太烦 原来写的也找不到了 不写了]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[头文件]]></title>
    <url>%2F2018%2F02%2F27%2F%E5%A4%B4%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[关键词: 头文件 头文件总结 头文件这种东西，偷一下就行了对吧 1234567891011121314151617181920212223242526272829303132333435363738//Williams Wu/*#include &lt;EGE.h&gt; //绘图头文件#define SHOW_CONSOLE*//*#include &lt;cstdio&gt; //定义输入/输出函数#include &lt;iostream&gt; //数据流输入/输出#include &lt;algorithm&gt; //STL通用算法#include &lt;cmath&gt; //定义数学函数#include &lt;cstdlib&gt; //定义杂项函数及内存分配函数#include &lt;cstring&gt; //字符串处理#include &lt;string&gt; //字符串类#include &lt;ctime&gt; //定义关于时间的函数*//*#include &lt;bitset&gt; //STL位集容器#include &lt;cstype&gt; //字符处理#include &lt;cerrno&gt; //定义错误码#include &lt;complex&gt; //复数类#include &lt;clocale&gt; //定义本地化函数#include &lt;deque&gt; //STL双端队列容器#include &lt;exception&gt; //异常处理类#include &lt;fstream&gt; //文件输入/输出#include &lt;functional&gt; //STL定义运算函数(代替运算符)#include &lt;limits&gt; //定义各种数据类型最值常量#include &lt;list&gt; //STL线性列表容器#include &lt;map&gt; //STL映射容器#include &lt;iomanip&gt; //参数化输入/输出#include &lt;ios&gt; //基本输入/输出支持#include &lt;iosfwd&gt; //输入/输出系统使用的前置声明#include &lt;istream&gt; //基本输入流#include &lt;ostream&gt; //基本输出流#include &lt;queue&gt; //STL队列容器#include &lt;set&gt; //STL集合容器#include &lt;sstream&gt; //基于字符串的流#include &lt;stack&gt; //STL堆栈容器#include &lt;stdexcept&gt; //标准异常类#include &lt;streambuf&gt; //底层输入/输出支持#include &lt;utility&gt; //STL通用模板类#include &lt;vector&gt; //STL动态数组容器#include &lt;cwchar.h&gt;//宽字符处理及输入/输出#include &lt;cwctype.h&gt; //宽字符分类*/ 上面一部分是分开来的各类头文件，如果想偷懒的的可以使用 1#include &lt;bits/stdc++.h&gt; 12345678910using namespace std;#define rep(x,y,z) for (int x=(y);(x)&lt;=(z);(x)++)#define rep_(x,y,z) for (int x=(y);(x)&lt;(z);(x)++)#define repf(x,y,z) for (int x=(y);(x)&gt;=(z);(x)--)#define repf_(x,y,z) for (int x=(y);(x)&gt;(z);(x)--)#define inf 0x3f3f3f3f //0x7fffffff#define cle(x) memset(x,0,sizeof(x))#define clemin(x) memset(x,-1,sizeof(x))#define clemax(x) memset(x,0x3f,sizeof(x)) //127typedef long long LL; 这一部分是各种宏定义，方便写程序，注意cle(x)表示清零，clemin()表示清成-1 123const double PI =3.14159265358979323846264338327950288419716939937510;const double e=2.7182818284590452353602874713526624977572470936999596;const double eps = 0.000000001; 定义一些常数 12int max(int x,int y)&#123;return x&gt;y?x:y;&#125;int min(int x,int y)&#123;return x&lt;y?x:y;&#125; 自己定义min和max，可以跑得快一点 1234///////////////////////optimize////////////////////////////#pragma GCC optimize("O2") //O2优化 //#pragma GCC optimize("Ofast") //Ofast优化 //ios::sync_with_stdio(false); //取消同步(加快流输入输出速度) Ofast和O2优化，还有取消同步 1234567//////////////////////////read///////////////////////////template &lt;typename T&gt;inline void read(T&amp; x)&#123;char ch;x=0;bool flag=false;ch=getchar();while (ch&gt;'9'||ch&lt;'0')&#123;if (ch=='-')flag=true;ch=getchar();&#125;while ((ch&lt;='9'&amp;&amp;ch&gt;='0')) &#123;x=x*10+ch-'0';ch=getchar();&#125;if(flag)x*=-1;&#125;template &lt;typename T&gt;inline void read(T&amp; x, T&amp; y)&#123;read(x);read(y);&#125;template &lt;typename T&gt;inline void read(T&amp; x, T&amp; y, T&amp; z)&#123;read(x);read(y);read(z);&#125; 读入优化 为了偷懒还设置了可以一次读入2、3个的 123456/////////////////variables&amp;functions/////////////////////__attribute__((optimize("Ofast"),target("no-ieee-fp,arch=amdfam10")))int main()&#123; xxx return 0;&#125; 至于加在int main前的那句话我也不知道是干啥的但是听一位大（基）佬说可以玄学优化那就加上了呗!]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>头文件</tag>
      </tags>
  </entry>
</search>
