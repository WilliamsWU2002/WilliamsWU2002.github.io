<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>矩阵乘法</title>
      <link href="/2018/09/13/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"/>
      <url>/2018/09/13/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/</url>
      <content type="html"><![CDATA[<blockquote><p>关键词: 矩阵乘法</p></blockquote><a id="more"></a><h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2>]]></content>
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>初级字符串算法</title>
      <link href="/2018/09/06/%E5%88%9D%E7%BA%A7%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"/>
      <url>/2018/09/06/%E5%88%9D%E7%BA%A7%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<blockquote><p>关键词: 字符串 </p></blockquote><a id="more"></a><h2 id="初级字符串算法"><a href="#初级字符串算法" class="headerlink" title="初级字符串算法"></a>初级字符串算法</h2><h3 id="最小表示法"><a href="#最小表示法" class="headerlink" title="最小表示法"></a>最小表示法</h3><p>这应该是个极其基础的字符串算法</p><p>这里说的<strong>最小表示法</strong>就是<strong>找出字符串$S$的的循环同构串中字典序最小的一个</strong>。<br>其实就是找到位置i，从这个位置输出$S​$，使得到的串字典序最小<br>（什么是循环同构串就不用解释了吧</p><p>其实还是有最大表示法的，主要部分的符号比较换一换就可以了</p><p>设$S$的长度为$len$<br>1.利用在任意时刻都不能相等的两个指针$i,j$。<br>2.初始化时$i$指向$s[0]$，$j$指向$s[1]$。<br>3.匹配长度为$k$从$0$开始，检验$s[i+k]$和$s[j+k]$的大小<br>第一种：$s[i+k]&gt;s[j+k]$，因为$s[i]-s[i+k-1]$和$s[j]-s[j+k-1]$一样，所以$s[i]-s[i+k-1]$必定不是最小表示的前缀 $i$滑动至$i+k+1$处。<br>第二种：$s[i+k]&lt;s[j+k]$，同理第一种，$j$滑动至$j+k+1$处。<br>第三种：$s[i+k]==s[j+k]$，那么$kk++$，然后继续比较直至找到第一个不相同的字符<br>(注意如果滑动后$i==j$，为了保证$i$和$j$不相等，将正在变化的指针$+1$)<br>4.若$k==len$，说明全字符串匹配了，那么那个位置就是最小表示位置，返回两个指针中较小的那个，即$min(i,j)$。</p><p>注意一点：<br>由于循环同构串需要复制一遍字串接在原序列后面<br>而如果题目卡空间的话有可能会MLE，那么我们就用$(i+k) \% n$和$(j+k)\%n$代表了各字符在原序列中的对应位置，这样可以省掉一半的空间。<br>例题为洛谷P1368工艺<br>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> seq[<span class="number">300100</span>];</span><br><span class="line"><span class="keyword">int</span> n,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc_min</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n&amp;&amp;j&lt;n&amp;&amp;k&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(seq[(i+k)%n]==seq[(j+k)%n]) k++;  <span class="comment">//两个位置相等，匹配长度k++</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(seq[(i+k)%n]&gt;seq[(j+k)%n]) i+=k+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> j+=k+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i==j) i++; <span class="comment">//任意时刻i!=j</span></span><br><span class="line">                k=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min(i,j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    rep_(i,<span class="number">0</span>,n) read(seq[i]);</span><br><span class="line">    ans=calc_min();</span><br><span class="line">    rep_(i,<span class="number">0</span>,n) <span class="built_in">printf</span>(<span class="string">"%d "</span>,seq[(i+ans)%n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果直接复制在原串后面的话<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[<span class="number">600100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">MINR</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n&amp;&amp;j&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num[i+len]==num[j+len]&amp;&amp;len&lt;=n) len++;    </span><br><span class="line">        <span class="keyword">if</span>(len==(n+<span class="number">1</span>)) <span class="keyword">return</span> min(i,j);</span><br><span class="line">        <span class="keyword">if</span>(num[i+len]&gt;num[j+len]) i=max(i+len+<span class="number">1</span>,j+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> j=max(j+len+<span class="number">1</span>,i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min(i,j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    read(n);</span><br><span class="line">    rep(i,<span class="number">1</span>,n)</span><br><span class="line">    &#123;</span><br><span class="line">        read(num[i]);</span><br><span class="line">        num[n+i]=num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=MINR(n);</span><br><span class="line">    rep(i,ans,ans+n<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"%d "</span>,num[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><p><strong>判断回文的方法</strong></p><p>1.暴力<br>枚举出该字符串的所有子串，判断其是否回文，时间复杂度是$O(n^3)$的</p><p>2.优化版暴力<br>因为回文串是对称的，那么可以遍历这些对称轴，在每个对称轴上同时向左和向右扩展，直到左右两边的字符不同或者到达边界，这样的时间复杂度$O(n^2)$<br>因为串的长度奇偶都有，所以需要判定一下，长度为奇数的以最中间字符为对称轴左右对称，而长度为偶数的对称轴在中间两个字符之间。</p><p>3.manacher算法<br>1）因为回文串长度的奇偶性造成了对称轴的位置可能在某字符上，也可能在两个字符之间的空隙处，而分别处理就比较烦，所以我们这样优化一下：<br>在每两个字符中间插入另一个字符，如’#’，为了方便以及不越界，$s[0]$也赋为‘#’</p><blockquote><p>aba ———&gt; #a#b#a#<br>abba ———&gt; #a#b#b#a#</p></blockquote><p>2）由于很多子串会被重复访问，导致时间效率大幅降低。<br>用数组$mxlen[i]$表示以$str[i]$为中心向左/右能够扩展出的回文长度（总回文长度的一半）<br>因此我们设置两个辅助变量：表示已经扩展到的最右边界的$maxr$以及表示这个回文子串的对称轴位置的$mid$。<br>于是我们从$str[1]$遍历到$str[len]$，注意$i$关于$mid$的对称点$j$（$mid \times 2-i$）<br>（由于图是盗来的 所以变量名不一 大家凑活着看吧）<br><img src="https://s1.ax1x.com/2018/09/13/iAygH0.png" alt=""><br>当$i$在$maxr$左边和$mid$右边时：<br>由于回文串是对称的，显然$mxlen[i]$一定不会小于$mxlen[j]$。<br>当$maxr-i&gt;mxlen[j]$的时候，以$str[j]$为中心的回文子串包含在以$str[mid]$为中心的max回文子串中，由于$i$和$j$都在大回文子串内部，所以对称，以$str[i]$为中心的回文子串必然也包含在max回文子串中，所以必有$mxlen[i]=mxlen[j]$。<br>而如果$maxr-i&lt;mxlen[j]$，那么就设$mxlen[i]=mxlen[j]$，然后继续向外暴力扩展<br>求出$mxlen[i]$，然后更新$maxr$和$mid$。<br>当$i$在$maxr$右边时：<br>一切都是未知的，没有可以利用的已匹配部分，所以从头开始暴力匹配，更新答案。<br>该算法的时间复杂度和空间复杂度都是线性的<br><strong>字符串中的优越算法基本上都离不开巧妙地运用已经“匹配”的部分</strong><br>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">101000100</span>],s[<span class="number">51000100</span>];</span><br><span class="line"><span class="keyword">int</span> mxlen[<span class="number">51000100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    str[<span class="number">0</span>]=str[<span class="number">1</span>]=<span class="string">'#'</span>;</span><br><span class="line">    rep_(i,<span class="number">0</span>,len)</span><br><span class="line">    &#123;</span><br><span class="line">        str[i*<span class="number">2</span>+<span class="number">2</span>]=s[i];</span><br><span class="line">        str[i*<span class="number">2</span>+<span class="number">3</span>]=<span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    len=len*<span class="number">2</span>+<span class="number">2</span>;  <span class="comment">//插入#后长度变化了</span></span><br><span class="line">    str[len]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxr=<span class="number">0</span>,mid=<span class="number">0</span>,ans=<span class="number">-1</span>;</span><br><span class="line">    rep_(i,<span class="number">1</span>,len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;maxr) mxlen[i]=min(mxlen[mid*<span class="number">2</span>-i],maxr-i);  <span class="comment">//在已知范围内的回文长度</span></span><br><span class="line">            <span class="keyword">else</span> mxlen[i]=<span class="number">1</span>;  <span class="comment">//对称中心已经超出已知范围</span></span><br><span class="line">        <span class="keyword">while</span>(str[i+mxlen[i]]==str[i-mxlen[i]]) mxlen[i]++;  <span class="comment">//暴力逐一比较未知范围的字符</span></span><br><span class="line">        <span class="keyword">if</span>(mxlen[i]+i&gt;maxr)  <span class="comment">//比原答案拓展到更右边</span></span><br><span class="line">        &#123;</span><br><span class="line">            maxr=mxlen[i]+i;  <span class="comment">//更新已拓展最右边</span></span><br><span class="line">            mid=i;  <span class="comment">//更新中间值</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans=max(ans,mxlen[i]<span class="number">-1</span>);  <span class="comment">//更新答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>单源最短路</title>
      <link href="/2018/09/04/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
      <url>/2018/09/04/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
      <content type="html"><![CDATA[<blockquote><p>关键词: 单源最短路</p></blockquote><a id="more"></a><h2 id="单源最短路"><a href="#单源最短路" class="headerlink" title="单源最短路"></a>单源最短路</h2><h3 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h3><p>用数组dis记录起点到每个结点的最短路径<br>用邻接表来存储图（邻接矩阵太浪费空间）<br>用队列来保存待优化的结点（类似于BFS）</p><p>每次取出队首结点来进行松弛操作并更新最短路径<br>如果要对所连点的最短路径需要更新，且点不在当前的队列中<br>就将该点加入队列，然后不断进行松弛操作，直至队列为空为止。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> first[<span class="number">10100</span>],nxt[<span class="number">500100</span>],u[<span class="number">500100</span>],v[<span class="number">500100</span>],w[<span class="number">500100</span>],dis[<span class="number">10100</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">10100</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="keyword">int</span> n,m,st;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    read(n,m,st);</span><br><span class="line">    <span class="comment">//clemax(dis);</span></span><br><span class="line">    rep(i,<span class="number">1</span>,<span class="number">10099</span>) dis[i]=<span class="number">2147483647</span>;  <span class="comment">//注意 洛谷要求走不通输出2147483647 （mdzz</span></span><br><span class="line">    dis[st]=<span class="number">0</span>;</span><br><span class="line">    clemin(first);</span><br><span class="line">    rep(i,<span class="number">1</span>,m)</span><br><span class="line">    &#123;</span><br><span class="line">        read(u[i],v[i],w[i]);</span><br><span class="line">        nxt[i]=first[u[i]];  <span class="comment">//建立邻接表</span></span><br><span class="line">        first[u[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    que.push(st);  <span class="comment">//一号顶点入队</span></span><br><span class="line">    cle(vis);</span><br><span class="line">    vis[st]=<span class="number">1</span>;  <span class="comment">//标记一号顶点已使用</span></span><br><span class="line">    <span class="keyword">while</span>(!que.empty())  <span class="comment">//队列不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> noww=first[que.front()];  <span class="comment">//当前队列中第一个入队</span></span><br><span class="line">        <span class="keyword">while</span>(noww!=<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[v[noww]]&gt;dis[u[noww]]+w[noww])  <span class="comment">//松弛边操作</span></span><br><span class="line">            &#123;</span><br><span class="line">                dis[v[noww]]=dis[u[noww]]+w[noww];</span><br><span class="line">                <span class="keyword">if</span>(!vis[v[noww]])</span><br><span class="line">                &#123;</span><br><span class="line">                    que.push(v[noww]);  <span class="comment">//被松弛顶点入队</span></span><br><span class="line">                    vis[v[noww]]=<span class="number">1</span>;  <span class="comment">//标记使用过</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            noww=nxt[noww];  <span class="comment">//下一条边</span></span><br><span class="line">        &#125;</span><br><span class="line">        vis[que.front()]=<span class="number">0</span>;  <span class="comment">//顶点出队并取消标记(允许下一次进入)</span></span><br><span class="line">        que.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,n)  <span class="built_in">printf</span>(<span class="string">"%d "</span>,dis[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><p><img src="https://s1.ax1x.com/2018/09/04/iS41nP.jpg" alt=""></p><p>由于NOI2018 Day1T1的出题人成功把使用SPFA的选手卡成60分<br>我们得出结论：<strong>SPFA死了！</strong>（笑</p><p>好吧 其实只是在考场上使用SPFA需要注意啦<br>在毒瘤数据面前它可能退化到$O(nm)$的复杂度<br>但是我们现在介绍的$Dijkstra$在无负边的情况下可以达到$O(nlogn)$且不会被卡<br>这个算法是基于一个贪心的策略的<br>老规矩，用数组$dis$记录起点到每个结点的最短路径<br>从$dis$数组选择最小值，则该值就是源点$st$到该值对应的顶点的最短路径<br>并且把该点记为已经找到最短路<br>此时完成一个顶点<br>再看这个点能否到达其它点，将$dis[noww]$的值进行更新<br>不断重复上述动作，将所有的点都更新到最短路径</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt; pair&lt;LL,<span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;pair&lt;LL,<span class="keyword">int</span>&gt; &gt;, greater&lt;pair&lt;LL,<span class="keyword">int</span>&gt; &gt; &gt; que; </span><br><span class="line"><span class="comment">//递增的优先队列，注意单调队列是根据pair的第一个元素来排列的，所以第一个元素放dis[]</span></span><br><span class="line"><span class="keyword">int</span> head[<span class="number">500100</span>],dis[<span class="number">100100</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">100100</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,st,cnt=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w,nxt;</span><br><span class="line">&#125;mapp[<span class="number">500100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mapp[++cnt].u=u;</span><br><span class="line">    mapp[cnt].v=v;</span><br><span class="line">    mapp[cnt].w=w;</span><br><span class="line">    mapp[cnt].nxt=head[u];  <span class="comment">//存储该点的下一条边</span></span><br><span class="line">    head[u]=cnt;  <span class="comment">//更新该点的最后一条边（也就是当前的边）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    read(n,m,st);</span><br><span class="line">    rep(i,<span class="number">1</span>,m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,w;</span><br><span class="line">        read(u,v,w);</span><br><span class="line">        add(u,v,w);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,n) dis[i]=<span class="number">2147483647</span>;</span><br><span class="line">    dis[st]=<span class="number">0</span>;</span><br><span class="line">    que.push(make_pair(<span class="number">0</span>,st));</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())  <span class="comment">//当堆不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> noww=que.top().second;</span><br><span class="line">        que.pop();  <span class="comment">//记录堆顶并将其弹出</span></span><br><span class="line">        <span class="keyword">if</span>(!vis[noww])  <span class="comment">//还没有遍历过</span></span><br><span class="line">        &#123;</span><br><span class="line">            vis[noww]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=head[noww];i;i=mapp[i].nxt) <span class="comment">//搜索堆顶所有连边</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp=mapp[i].v;</span><br><span class="line">                dis[tmp]=min(dis[tmp],dis[noww]+mapp[i].w); <span class="comment">//松弛操作</span></span><br><span class="line">                que.push(make_pair(dis[tmp],tmp));  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,n) <span class="built_in">printf</span>(<span class="string">"%d "</span>,dis[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>求质数的方法</title>
      <link href="/2018/08/29/%E6%B1%82%E8%B4%A8%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2018/08/29/%E6%B1%82%E8%B4%A8%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<blockquote><p>关键词: 质数</p></blockquote><a id="more"></a><h2 id="求质数的方法"><a href="#求质数的方法" class="headerlink" title="求质数的方法"></a>求质数的方法</h2><h3 id="第一类问题"><a href="#第一类问题" class="headerlink" title="第一类问题"></a>第一类问题</h3><p><strong>给出一个数。判断它是不是质数</strong></p><h4 id="O-n-的方法"><a href="#O-n-的方法" class="headerlink" title="$O(n)$的方法"></a>$O(n)$的方法</h4><p>最最最最最朴素的判断质数法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rep_(i,<span class="number">2</span>,n)</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="O-sqrt-n-的方法"><a href="#O-sqrt-n-的方法" class="headerlink" title="$O(\sqrt{n})$的方法"></a>$O(\sqrt{n})$的方法</h4><p>稍微优化了一下就可以了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_prime</span><span class="params">(LL n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(LL i=<span class="number">2</span>;i*i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Miller-Rabin素性测试"><a href="#Miller-Rabin素性测试" class="headerlink" title="Miller_Rabin素性测试"></a>Miller_Rabin素性测试</h4><p>尽管上面的$O(\sqrt{n})$的算法已经非常优秀了，但是面对更高数量级的“大数”却会显得力不从心。而这个时候，Miller_Rabin的优越性就显示出来了。</p><p>Miller_Rabin的理论基础来源于费马小定理。值得一提的是费马小定理是数论四大定理之一。</p><p>费马小定理：$n$是一个奇素数，$a$是任何整数$(1≤ a≤n-1)$ ，则 $a^{(n-1)}  \equiv 1  (mod  n)$</p><p>要测试$n$是否是一个素数，首先将$n-1$分解为$(2^p) * tmp$，在每次测试开始时，先随机选择一个介于$[1, n - 1]$的整数$a$，计算出$a^{tmp}mod  n$；算出来之后也不一定是素数，而是伪素数，再运用二项式探测定理，去检测：$x^2 \equiv 1(mod  p)$，当$x_1=1$或$x_2=p-1$时成立。如果不符合，则是合数，如果符合，则有25%的概率为质数，那么经过$t$轮测试,$p$不是素数的概率为$\dfrac {1}{4^{t}}$，这也是为什么这个算法被称为素性测试了，它不能完全保证结果正确，而我们用2,3,5,7,11,13,17,192,3,5,7,11,13,17,19这些数进行判断，在信息学范围内基本上就不会出错了（笑</p><p>它的代码可以这么写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">LL test[]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">poww</span><span class="params">(LL a,LL p,LL MOD)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p&amp;<span class="number">1</span>) res=(res*a)%MOD;</span><br><span class="line">        a=(a*a)%MOD;</span><br><span class="line">        p&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">mr_test</span><span class="params">(LL n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rep(i,<span class="number">0</span>,<span class="number">7</span>)</span><br><span class="line">        <span class="keyword">if</span>(n==test[i]) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>((!(n&amp;<span class="number">1</span>))||n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    LL tmp=n<span class="number">-1</span>,p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!(tmp&amp;<span class="number">1</span>)) <span class="comment">//把n-1拆分为2^p*tmp的形式</span></span><br><span class="line">    &#123;</span><br><span class="line">        tmp&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">0</span>,<span class="number">7</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LL a=test[i];  <span class="comment">//选择一个测试数</span></span><br><span class="line">        LL x=poww(a,tmp,n);  <span class="comment">//计算a^tmp mod n</span></span><br><span class="line">        LL y=x;</span><br><span class="line">        rep(j,<span class="number">1</span>,p)</span><br><span class="line">        &#123;</span><br><span class="line">            y=(x*x)%n;</span><br><span class="line">            <span class="keyword">if</span>(y==<span class="number">1</span>&amp;&amp;x!=<span class="number">1</span>&amp;&amp;x!=n<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//违背二次探测定理 为合数</span></span><br><span class="line">            x=y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x!=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//最后算出的数不为1也是合数（费马小定理）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二类问题"><a href="#第二类问题" class="headerlink" title="第二类问题"></a>第二类问题</h3><p><strong>求整数区间$[1,n]$的质数的个数和值</strong><br>我们遇到这种问题的时候一般用筛选法解答</p><h4 id="埃拉托斯特尼筛法"><a href="#埃拉托斯特尼筛法" class="headerlink" title="埃拉托斯特尼筛法"></a>埃拉托斯特尼筛法</h4><p>这个筛法的复杂度是$O(n  log  log  n)$<br>根据质数的整数倍一定不是质数的性质筛选即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//埃拉托斯特尼筛法</span></span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">1000100</span>];</span><br><span class="line"><span class="keyword">int</span> n,cnt=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    cle(vis); </span><br><span class="line">    vis[<span class="number">1</span>]=<span class="number">1</span>;  <span class="comment">//1是素数</span></span><br><span class="line">    rep(i,<span class="number">2</span>,<span class="built_in">sqrt</span>(n))  <span class="comment">//只需要算到sqrt(n)就行了</span></span><br><span class="line">        <span class="keyword">if</span>(vis[i]==<span class="number">0</span>)  <span class="comment">//当前数是素数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j*i&lt;=n;j++)  <span class="comment">//素数的整数倍不是素数</span></span><br><span class="line">                vis[i*j]=<span class="number">1</span>;  <span class="comment">//标记</span></span><br><span class="line">    rep(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="keyword">if</span>(vis[i]==<span class="number">0</span>)</span><br><span class="line">        <span class="comment">/*&#123;</span></span><br><span class="line"><span class="comment">            cnt++;*/</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,i);</span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="comment">//printf("%d\n",cnt);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h4><p> 这就是大名鼎鼎的线性复杂度的<strong>欧拉筛</strong><br>显然我们会发现用埃氏筛法的时候有些合数被筛了不止一次<br>所以在欧拉筛中我们针对此进行了优化<br>保证每个合数只会被它的最小质因数筛去<br>因此每个数只会被筛一次<br>那么复杂度就可以了到达$O(n)$了！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//欧拉筛法</span></span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">10000100</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">10000100</span>];</span><br><span class="line"><span class="keyword">int</span> n,cnt=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    cle(vis);</span><br><span class="line">    cle(prime);</span><br><span class="line">    rep(i,<span class="number">2</span>,n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) prime[cnt++]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cnt&amp;&amp;i*prime[j]&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i*prime[j]]=<span class="number">1</span>;  <span class="comment">//已经找到的素数的倍数</span></span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//因为prime[j]*k=i 所以i*prime[j+1]=prime[j]*(k*prime[j+1]) </span></span><br><span class="line">            <span class="comment">//所以必定会被prime[j]筛掉 而prime[]是递增的 那么就不需要再筛了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep_(i,<span class="number">0</span>,cnt)  <span class="built_in">printf</span>(<span class="string">"%d "</span>,prime[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="comment">//printf("%d\n",cnt);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Meissel-Lehmer算法"><a href="#Meissel-Lehmer算法" class="headerlink" title="Meissel-Lehmer算法"></a>Meissel-Lehmer算法</h4><p>暂时还不会，坑先占着。</p>]]></content>
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>快速读入</title>
      <link href="/2018/08/29/%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%85%A5/"/>
      <url>/2018/08/29/%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%85%A5/</url>
      <content type="html"><![CDATA[<blockquote><p>关键词: 快速读入</p></blockquote><a id="more"></a><h3 id="快速读入"><a href="#快速读入" class="headerlink" title="快速读入"></a>快速读入</h3><h4 id="普通的读入优化"><a href="#普通的读入优化" class="headerlink" title="普通的读入优化"></a>普通的读入优化</h4><p>因为getchar()的速度远快于scanf或是cin，所以我们就想到利用getchar()一个一个读入字符然后把它转化为原来类型的变量就可以了，然后优化了一下，方便读入多个变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span></span>&#123;<span class="keyword">char</span> id;x=<span class="number">0</span>;<span class="keyword">bool</span> flag=<span class="literal">false</span>;id=getchar();</span><br><span class="line">  <span class="keyword">while</span>(id&gt;<span class="string">'9'</span>||id&lt;<span class="string">'0'</span>)&#123;<span class="keyword">if</span>(id==<span class="string">'-'</span>)flag=<span class="literal">true</span>;id=getchar();&#125;</span><br><span class="line">  <span class="keyword">while</span>((id&lt;=<span class="string">'9'</span>&amp;&amp;id&gt;=<span class="string">'0'</span>)) &#123;x=x*<span class="number">10</span>+id-<span class="string">'0'</span>;id=getchar();&#125;<span class="keyword">if</span>(flag)x*=<span class="number">-1</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x,T&amp; y)</span></span>&#123;read(x);read(y);&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x,T&amp; y,T&amp; z)</span></span>&#123;read(x);read(y);read(z);&#125;</span><br></pre></td></tr></table></figure><h4 id="利用fread的读入优化"><a href="#利用fread的读入优化" class="headerlink" title="利用fread的读入优化"></a>利用fread的读入优化</h4><p>在有些毒瘤题出现的时候，因为读入量是在太大，连getchar()都过不去，那么我们想到利用fread一次把所有的输入都读完，然后在buf[]数组里一个一个取出来，就完成了读入，但是要注意fread会把所有输入都读完，所以之后就不要再用其他读入了（上次就因为这个炸了好几发 嘤嘤嘤）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> fast_IO</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> IN_LEN=<span class="number">1000000</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">char</span> buf[IN_LEN],*s,*t;</span><br><span class="line">        <span class="keyword">return</span> (s==t?t=(s=buf)+fread(buf,<span class="number">1</span>,IN_LEN,<span class="built_in">stdin</span>),(s==t?<span class="number">-1</span>:*s++):*s++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>)</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">bool</span> iosig;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">for</span>(iosig=<span class="literal">false</span>,c=read();!<span class="built_in">isdigit</span>(c);c=read())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">'-'</span>) iosig=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;<span class="built_in">isdigit</span>(c);c=read()) x=((x+(x&lt;&lt;<span class="number">2</span>))&lt;&lt;<span class="number">1</span>)+(c^<span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">if</span>(iosig) x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> OUT_LEN=<span class="number">10000000</span>;</span><br><span class="line">    <span class="keyword">char</span> obuf[OUT_LEN],*ooh=obuf;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ooh==obuf+OUT_LEN)</span><br><span class="line">        &#123;</span><br><span class="line">            fwrite(obuf,<span class="number">1</span>,OUT_LEN,<span class="built_in">stdout</span>);</span><br><span class="line">            ooh=obuf;</span><br><span class="line">        &#125;</span><br><span class="line">        *ooh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">inline</span> <span class="title">void</span> <span class="title">print</span>(<span class="title">T</span> <span class="title">x</span>)</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> buf[<span class="number">30</span>],cnt;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>) print(<span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    print(<span class="string">'-'</span>);</span><br><span class="line">                    x=-x;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(cnt=<span class="number">0</span>;x;x/=<span class="number">10</span>) buf[++cnt]=x%<span class="number">10</span>+<span class="number">48</span>;</span><br><span class="line">                <span class="keyword">while</span>(cnt) print((<span class="keyword">char</span>)buf[cnt--]);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fwrite(obuf,<span class="number">1</span>,ooh-obuf,<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> fast_IO;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 头文件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>乘法逆元</title>
      <link href="/2018/05/28/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/"/>
      <url>/2018/05/28/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/</url>
      <content type="html"><![CDATA[<blockquote><p>关键词: 乘法逆元 </p></blockquote><a id="more"></a><h2 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>满足 $b \times k ≡ 1  (mod  p)$的$k$的值就是$b$关于$p$的乘法逆元。<br><strong>这里我们只讨论当模数$p$为素数的情况，因为如果模数不为素数，则不一定每个数都有逆元。</strong></p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>乘法逆元一大重要应用就是模意义下的除法<br>因为$(a \div b)  mod  p \neq a  mod  p+b  mod  p $<br>所以当我们要求$(a \div b)  mod  p$的值，且$a$很大，无法直接求得$a \div b$的值时，我们就要用到乘法逆元。 </p><h3 id="欧几里得"><a href="#欧几里得" class="headerlink" title="欧几里得"></a>欧几里得</h3><p><strong>最大公约数  gcd</strong><br>$gcd(a,b)=\left \{ a \qquad \qquad \quad b=0 \atop gcd(b,a \, mod \, b ) \quad  b \neq 0\right.$<br>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>最小公倍数  lcm</strong><br>而两数相乘除以最大公约数即为最小公倍数<br>$lcm(a,b)=\left \{ {\frac{a \times b}{gcd(a.b)}} \right.$<br>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a/gcd(a,b)*b;  <span class="comment">//注意先除后乘防爆int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h3><p>扩展欧几里得 <strong><em>exgcd</em></strong> 可以在$O(log  max(a, b))$的复杂度内求出$gcd(a,b)$的同时求出二元一次不定方程 $ax+by=gcd(a,b)$的一组整数解。</p><p>$eg:$ 求$gcd(47,30)$<br>通过欧几里得我们可以得到以下式子：<br>$47\div30=1…17$<br>$30\div17=1…13$<br>$17\div13=1…4$<br>$13\div4=3…1$</p><p>把余数移到一边<br>$17=47+30\times(-1)$<br>$13=30+17\times(-1)$<br>$4=17+13\times(-1)$<br>$1=13+4\times(-3)$</p><p>从 $gcd(47,30)=1$ 开始，将四个式子依次带入，得<br>$gcd(47,30)$<br>$=1$<br>$=13\times1+4\times(-3)$<br>$=13\times1+(17+13\times(-1))\times(-3)$<br>$=13\times4+17\times(-3)$<br>$=(30+17\times(-1))\times4+17\times(-3)$<br>$=17\times(-7)+30\times4$<br>$=(47+30\times(-1))\times(-7)+30\times4$<br>$=47\times(-7)+30\times11$</p><p>$So$ 解得 $x=-7,y=11$。</p><p>由上述式子可观察到，每次辗转交换了$x$和$y$，并将$y$减去了原$x$与辗转相除所得商的乘积。</p><p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> g,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">        y=<span class="number">0</span>;</span><br><span class="line">        g=a;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        exgcd(b,a%b,g,y,x);</span><br><span class="line">        y-=x*(a/b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="扩展欧几里得求乘法逆元"><a href="#扩展欧几里得求乘法逆元" class="headerlink" title="扩展欧几里得求乘法逆元"></a>扩展欧几里得求乘法逆元</h3><p><strong>用扩展欧几里得求逆元要求 $gcd(b, p) =1$</strong></p><p>我们可以通过求$b$关于$p$的乘法逆元$k$，再求 $(a \times k)  mod  p$。其结果与$(a \div b)  mod  p$等价。</p><p><strong>证明</strong>:<br>因为 $b \times k ≡ 1  (mod  p)$<br>则有 $b \times k = p \times x+1$<br>得到 $k = (p \times x + 1) \div b$<br>将 $k$ 代入$(a \times k)  mod  p$<br>得到：<br>$((p \times x + 1) \times a \div b)  mod  p$<br>$=(p \times x \times a \div b + a \div b)  mod  p$<br>$=[(a \times p \times x \div b)  mod  p +(a \div b)  mod  p]  mod  p$<br>$=[(p \times (a \times x \div b))  mod  p +(a \div b)  mod  p]  mod  p$<br>$= (a \div b)  mod  p$</p><p>代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a,<span class="keyword">const</span> <span class="keyword">int</span> b,<span class="keyword">int</span> &amp;g,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        g=a;</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">        y=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            exgcd(b,a%b,g,y,x);</span><br><span class="line">            y-=x*(a/b);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> num)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> g,x,y;</span><br><span class="line">    exgcd(num,mod,g,x,y);</span><br><span class="line">    <span class="keyword">return</span> ((x%mod)+mod)%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="费马小定理求乘法逆元"><a href="#费马小定理求乘法逆元" class="headerlink" title="费马小定理求乘法逆元"></a>费马小定理求乘法逆元</h3><p><strong>费马小定理：</strong><br>$a^{p-1}≡1  (mod  p)$ ($p$为质数)<br>变形可得：<br>$a \times a^{p-2}≡1  (mod  p)$<br>由定义可以知道$a^{p-2}$即为$a$的乘法逆元<br> 利用快速幂计算$a^{p-2}$<br> 所以总复杂度是$O(log  a)$<br> 我觉得还是比较慢的<br> 好像比较容易T掉</p><p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> n,<span class="keyword">const</span> <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL num=n,t=k;t;num=num*num%MOD,t&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span>(t&amp;<span class="number">1</span>) </span><br><span class="line">    ans=ans*num%MOD;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(num,MOD<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>treap</title>
      <link href="/2018/05/12/treap/"/>
      <url>/2018/05/12/treap/</url>
      <content type="html"><![CDATA[<blockquote><p>关键词: treap </p></blockquote><a id="more"></a><h2 id="Treap"><a href="#Treap" class="headerlink" title="Treap"></a>Treap</h2><p>  Treap是一个优先值域满足堆的性质的二叉搜索树<br>  建树时随机给每个节点赋随机优先值<br>  要求 节点的优先值域满足堆的性质 &amp;&amp;节点的值满足二叉搜索树的性质</p><h3 id="小知识普及"><a href="#小知识普及" class="headerlink" title="小知识普及"></a>小知识普及</h3><p>  二叉查找树(Binary Search Tree)或者是一棵空树，或者是具有下列性质的二叉树</p><ol><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li><p>它的左、右子树也分别为二叉查找树。</p><p>故中序遍历二叉搜索树即可得到有序序列</p><p>前序遍历 根左右 在本图即为ABDECF<br>中序遍历 左根右 DBEAFC<br>后序遍历 左右根 DEBFCA<br><img src="https://s1.ax1x.com/2018/05/11/C0UQ8e.png" alt="简单的二叉树"></p></li></ol><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>  每个操作<strong>期望</strong>复杂度都为O(log n)</p><p>  <strong><em>插入</em></strong>：由于期望树高h为log n<br>  插入操作是将待插入点放入叶节点并不断按要求旋转<br>  （跟维护堆一样，如果当前节点的优先级比根大就旋转，如果当前节点是根的左儿子就右旋如果当前节点是根的右儿子就左旋。）<br>  故最多进行复杂度为O(1)的旋转操作h次</p><p>  <strong><em>删除</em></strong>：同理插入<br>  删除是把待删除节点转到叶节点上然后直接删除即可<br>  （每次找到优先级最大的儿子，向与其相反的方向旋转）<br>  故最多也是进行h次旋转操作</p><p>  <strong><em>查找</em></strong>：由于treap是二叉搜索树 但是是随机化结构<br>  故期望O(log n)</p><p>  <strong><em>分离</em></strong>： 要把一个Treap按大小分成两个Treap，只要在需要分开的位置加一个虚拟节点，然后旋至根节点删除，左右两个子树就是得出的两个Treap。<br>  而根据二叉搜索树的性质，这时左子树的所有节点都小于右子树的节点。 </p><p>  <strong><em>合并</em></strong>： 合并两棵平衡树的条件正好是上方分离操作的结果<br>  要求其中第一棵树的所有节点都必须小于或等于第二棵树中的所有节点<br>  所以操作过程也正好与分离相反<br>  只需要加一个虚拟的根，把两棵树分别作为左右子树，然后删除根即可</p><p>  <strong><em>查找排名第 k 的元素</em></strong>  在一棵二叉搜索树中，根节点的排名取决于其左子树的大小<br>  而我们知道treap的子树还是treap 由于节点有重复 所以如果当前节点P满足P.left.size&lt;=k&lt;=P.left.size+P.weight  那么P就是排名第K的元素<br>   若满足 k &lt; P.left.size + 1，则在左子树中查找排名第 k 的元素；<br>   若满足 k &gt; P.left.size + P.weight，则在右子树中查找排名第 k-(P.left.size + P.weight)的元素。</p><p>  <strong><em>排名</em></strong> 如果没有重复元素 那么此操作与查找排名第 k 的元素为严格的逆运算<br>  cur为当前已知的比要求的元素小的元素个数<br>  当前节点等于目标 排名为P.left.size + cur + 1  （有重复的排名取最小）<br>  当前节点大于目标，在左子树中查找排名；<br>  当前元素小于目标，更新 cur 为 cur + P.left.size+weight，在右子树中查找排名</p><h3 id="基本动作-旋转"><a href="#基本动作-旋转" class="headerlink" title="基本动作 旋转"></a>基本动作 旋转</h3><p><img src="https://s1.ax1x.com/2018/05/11/C0yna9.png" alt="enter image description here"><br><strong><em>左旋</em></strong>    (A节点)</p><ol><li>获取根节点A的右儿子节点B</li><li>将节点B的父亲节点信息更新为f （双向）</li><li>将节点A的右儿子信息更新为节点B的左儿子D （双向）</li><li>将节点B的左儿子信息更改为节点A （双向）</li></ol><p>代码1(有父亲节点域的)：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LTURN</span><span class="params">(<span class="keyword">int</span> u)</span>  <span class="comment">//左旋</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    treap[treap[u].pre].r=treap[u].l;</span><br><span class="line">    treap[treap[u].l].pre=treap[u].pre;  <span class="comment">//将u的父亲作为u的左儿子的父亲</span></span><br><span class="line">    <span class="keyword">int</span> tmp=treap[treap[u].pre].pre;  </span><br><span class="line">    treap[u].l=treap[u].pre;</span><br><span class="line">    treap[treap[u].pre].pre=u;  <span class="comment">//将u作为与u的父亲的父亲</span></span><br><span class="line">    treap[u].pre=tmp;  <span class="comment">//将原来根节点的上继节点赋给新的根节点（也就是要旋转的u）</span></span><br><span class="line">    <span class="keyword">if</span>(tmp!=<span class="number">0</span>)  <span class="comment">//如果根节点的上继节点不为0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(treap[u].value&lt;treap[tmp].value) treap[tmp].l=u;  <span class="comment">//将根节点赋为根节点的上继节点的左儿子</span></span><br><span class="line">        <span class="keyword">else</span> treap[tmp].r=u;  <span class="comment">//（同上）右儿子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//根节点的上继节点为0</span></span><br><span class="line">    &#123;</span><br><span class="line">        root=u;  <span class="comment">//u为正式的根节点</span></span><br><span class="line">        <span class="comment">//treap[root].pre=0;  //正式把根节点的上继节点赋为0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码2(无父亲节点域的)：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lturn</span><span class="params">(<span class="keyword">int</span> &amp;k)</span>  <span class="comment">//由于没有父亲域 所以不需要双向改动</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=treap[k].r;  <span class="comment">//tmp即为将来根</span></span><br><span class="line">    treap[k].r=treap[tmp].l;  <span class="comment">//改变目前根的右节点为将来根的左节点</span></span><br><span class="line">    treap[tmp].l=k;  <span class="comment">//改变将来根的左节点为目前根</span></span><br><span class="line">    treap[tmp].size=treap[k].size;  <span class="comment">//更新将来根的节点数</span></span><br><span class="line">    update(k);  <span class="comment">//更新目前根的节点数</span></span><br><span class="line">    k=tmp;  <span class="comment">//改变根</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://s1.ax1x.com/2018/05/11/C0UvxH.png" alt="enter image description here"></p><p><strong><em>右旋</em></strong> (A节点)<br>操作为左旋的镜像</p><ol><li>获取根节点A的<strong>左</strong>儿子节点B</li><li>将节点B的父亲节点信息更新为f （双向）</li><li>将节点A的<strong>左</strong>儿子信息更新为节点B的<strong>右</strong>儿子D （双向）</li><li>将节点B的<strong>右</strong>儿子信息更改为节点A （双向）</li></ol><p>代码1：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RTURN</span><span class="params">(<span class="keyword">int</span> u)</span>  <span class="comment">//右旋 操作同左旋</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    treap[treap[u].pre].l=treap[u].r;</span><br><span class="line">    treap[treap[u].r].pre=treap[u].pre;</span><br><span class="line">    <span class="keyword">int</span> tmp=treap[treap[u].pre].pre;</span><br><span class="line">    treap[u].r=treap[u].pre;</span><br><span class="line">    treap[treap[u].pre].pre=u;</span><br><span class="line">    treap[u].pre=tmp;</span><br><span class="line">    <span class="keyword">if</span>(tmp!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(treap[u].value&lt;treap[tmp].value) treap[tmp].l=u;</span><br><span class="line">        <span class="keyword">else</span> treap[tmp].r=u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        root=u;</span><br><span class="line">        <span class="comment">//treap[root].pre=0;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rturn</span><span class="params">(<span class="keyword">int</span> &amp;k)</span>  <span class="comment">//同理左旋</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=treap[k].l;</span><br><span class="line">    treap[k].l=treap[tmp].r;</span><br><span class="line">    treap[tmp].r=k;</span><br><span class="line">    treap[tmp].size=treap[k].size;</span><br><span class="line">    update(k);</span><br><span class="line">    k=tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2018/05/11/C0aSsA.png" alt="enter image description here"></p><h3 id="模板代码："><a href="#模板代码：" class="headerlink" title="模板代码："></a>模板代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Williams Wu</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,value,rnd,amount,size;</span><br><span class="line">    <span class="comment">//左右儿子 值 随机的优先值 </span></span><br><span class="line">    <span class="comment">//.amount为某个值多次出现的个数 用来代替重复的节点</span></span><br><span class="line">    <span class="comment">//.size为以当前节点为根的子树大小 是查询排名的必备 在删除 旋转 插入时都会改变</span></span><br><span class="line">&#125;;</span><br><span class="line">node treap[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> n,size,root,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;  <span class="comment">//更新结点信息</span></span><br><span class="line">    treap[k].size=treap[treap[k].l].size+treap[treap[k].r].size+treap[k].amount;  </span><br><span class="line">    <span class="comment">//一个节点的路径数等于左右儿子路径数与节点数值重复次数之和</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lturn</span><span class="params">(<span class="keyword">int</span> &amp;k)</span>  <span class="comment">//由于没有父亲域 所以不需要双向改动</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=treap[k].r;  <span class="comment">//tmp即为将来根</span></span><br><span class="line">    treap[k].r=treap[tmp].l;  <span class="comment">//改变目前根的右节点为将来根的左节点</span></span><br><span class="line">    treap[tmp].l=k;  <span class="comment">//改变将来根的左节点为目前根</span></span><br><span class="line">    treap[tmp].size=treap[k].size;  <span class="comment">//更新将来根的节点数</span></span><br><span class="line">    update(k);  <span class="comment">//更新目前根的节点数</span></span><br><span class="line">    k=tmp;  <span class="comment">//改变根</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rturn</span><span class="params">(<span class="keyword">int</span> &amp;k)</span>  <span class="comment">//同理左旋</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=treap[k].l;</span><br><span class="line">    treap[k].l=treap[tmp].r;</span><br><span class="line">    treap[tmp].r=k;</span><br><span class="line">    treap[tmp].size=treap[k].size;</span><br><span class="line">    update(k);</span><br><span class="line">    k=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;k,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        k=++size;</span><br><span class="line">        treap[k].size=treap[k].amount=<span class="number">1</span>;</span><br><span class="line">        treap[k].value=x;</span><br><span class="line">        treap[k].rnd=rand();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;  <span class="comment">//插入叶子结点</span></span><br><span class="line">    treap[k].size++;  <span class="comment">//每经过一个节点，都要先使以它为根的子树的大小增加 1，再递归进入子树查找</span></span><br><span class="line">    <span class="keyword">if</span>(treap[k].value==x)   treap[k].amount++;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;treap[k].value)   <span class="comment">//应在根的右边</span></span><br><span class="line">        &#123;</span><br><span class="line">            insert(treap[k].r,x);  <span class="comment">//继续用根节点的右儿子搜索</span></span><br><span class="line">            <span class="keyword">if</span>(treap[treap[k].r].rnd&lt;treap[k].rnd) lturn(k);  <span class="comment">//维护完二叉搜索树的性质后开始维护堆的性质（旋转）</span></span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                insert(treap[k].l,x);   <span class="comment">//左儿子</span></span><br><span class="line">                <span class="keyword">if</span>(treap[treap[k].l].rnd&lt;treap[k].rnd)rturn(k); <span class="comment">//右旋</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> &amp;k,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span>;  <span class="comment">//已到叶子结点 可以删除 </span></span><br><span class="line">    <span class="keyword">if</span>(treap[k].value==x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(treap[k].amount&gt;<span class="number">1</span>)  <span class="comment">//如果该节点不止一个 重复数量减掉一个即可</span></span><br><span class="line">        &#123;</span><br><span class="line">            treap[k].amount--;</span><br><span class="line">            treap[k].size--;  <span class="comment">//子树大小减1</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(treap[k].l*treap[k].r==<span class="number">0</span>)  k=treap[k].l+treap[k].r; <span class="comment">//如果左右节点中有任何一个是叶子结点 直接替换当前根</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(treap[treap[k].l].rnd&lt;treap[treap[k].r].rnd)  <span class="comment">//左子树的随机值比右子树小</span></span><br><span class="line">            &#123;</span><br><span class="line">                rturn(k);  <span class="comment">//右旋</span></span><br><span class="line">                del(k,x);  <span class="comment">//继续讨论</span></span><br><span class="line">            &#125;</span><br><span class="line">                <span class="keyword">else</span>  <span class="comment">//反之亦然</span></span><br><span class="line">                &#123;</span><br><span class="line">                    lturn(k);</span><br><span class="line">                    del(k,x);</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;treap[k].value)</span><br><span class="line">        &#123;</span><br><span class="line">            treap[k].size--;  </span><br><span class="line">            <span class="comment">//递归返回时要把所有的经过的节点的子树的大小减1。注意 删除前要保证待删除节点存在于树中</span></span><br><span class="line">            del(treap[k].r,x);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                treap[k].size--;</span><br><span class="line">                del(treap[k].l,x);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ranknum</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(treap[k].value==x) <span class="keyword">return</span> treap[treap[k].l].size+<span class="number">1</span>;  <span class="comment">//左子树全部比根小 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;treap[k].value)</span><br><span class="line">            <span class="keyword">return</span> treap[treap[k].l].size+treap[k].amount+ranknum(treap[k].r,x);  <span class="comment">//注意要加上重复的个数</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> ranknum(treap[k].l,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rerank</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"><span class="comment">//根据二叉搜索树的性质 根节点的rank取决于其左子树的大小</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=treap[treap[k].l].size)</span><br><span class="line">        <span class="keyword">return</span> rerank(treap[k].l,x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;treap[treap[k].l].size+treap[k].amount)  <span class="comment">//注意当前节点可能有多个重复的</span></span><br><span class="line">            <span class="keyword">return</span> rerank(treap[k].r,x-treap[treap[k].l].size-treap[k].amount);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> treap[k].value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">provalue</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span>  <span class="comment">//注意定义 小于/不大于</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)<span class="keyword">return</span>;  <span class="comment">//当前节点为空节点 查找结束 最优节点ans即为所求</span></span><br><span class="line">    <span class="keyword">if</span>(treap[k].value&lt;x)  <span class="comment">//当前元素小于目标  </span></span><br><span class="line">    &#123;</span><br><span class="line">        ans=k;  <span class="comment">//更新最优节点</span></span><br><span class="line">        provalue(treap[k].r,x);  <span class="comment">//并访问当前节点的右儿子</span></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">else</span> provalue(treap[k].l,x);  <span class="comment">//不满足条件 访问当前节点的左儿子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nextvalue</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(treap[k].value&gt;x)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=k;</span><br><span class="line">        nextvalue(treap[k].l,x);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">else</span> nextvalue(treap[k].r,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">int</span> opt,x;</span><br><span class="line">    rep(i,<span class="number">1</span>,n)</span><br><span class="line">    &#123;</span><br><span class="line">        read(opt,x);</span><br><span class="line">        <span class="keyword">switch</span>(opt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:insert(root,x); <span class="keyword">break</span>;  <span class="comment">//插入</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:del(root,x); <span class="keyword">break</span>;  <span class="comment">//删除</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ranknum(root,x)); <span class="keyword">break</span>;   <span class="comment">//排名</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,rerank(root,x)); <span class="keyword">break</span>;   <span class="comment">//排名反向</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:ans=<span class="number">0</span>;provalue(root,x); <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,treap[ans].value);<span class="keyword">break</span>;   <span class="comment">//前驱（小于的max）</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:ans=<span class="number">0</span>;nextvalue(root,x); <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,treap[ans].value);<span class="keyword">break</span>;   <span class="comment">//后继（大于的min）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高级数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>高精度</title>
      <link href="/2018/03/01/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
      <url>/2018/03/01/%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
      <content type="html"><![CDATA[<blockquote><p>关键词: 高精度 </p></blockquote><a id="more"></a><h3 id="高精度总结"><a href="#高精度总结" class="headerlink" title="高精度总结"></a>高精度总结</h3><blockquote><p>高精度这种基础知识还是需要复习一下的，所以干脆来总结一下</p></blockquote><h4 id="1-高精度加法"><a href="#1-高精度加法" class="headerlink" title="1.高精度加法"></a>1.高精度加法</h4><p>就是模拟竖式，处理一下进位就好了，需要注意读入的时候用scanf()比较保险，别乱用gets，还有就是加完前导零需要处理。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">头文件省略</span><br><span class="line"><span class="comment">//另一种写法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">char as[11001],bs[11001];</span></span><br><span class="line"><span class="comment">int a[11001],b[11001],c[11002];</span></span><br><span class="line"><span class="comment">int la,lb,lc;</span></span><br><span class="line"><span class="comment">int main()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cle(a); cle(b); cle(c);</span></span><br><span class="line"><span class="comment">scanf("%s%s",as,bs);</span></span><br><span class="line"><span class="comment">la=strlen(as);</span></span><br><span class="line"><span class="comment">lb=strlen(bs);</span></span><br><span class="line"><span class="comment">rep_(i,0,la)  a[i+1]=as[i]-'0';</span></span><br><span class="line"><span class="comment">rep_(i,0,lb)  b[i+1]=bs[i]-'0';</span></span><br><span class="line"><span class="comment">rep(i,1,la/2)  swap(a[i],a[la-i+1]);</span></span><br><span class="line"><span class="comment">rep(i,1,lb/2)  swap(b[i],b[lb-i+1]);</span></span><br><span class="line"><span class="comment">if(la&gt;lb)  lc=la;</span></span><br><span class="line"><span class="comment">else lc=lb;</span></span><br><span class="line"><span class="comment">rep(i,1,lc)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">c[i]=c[i]+a[i]+b[i];</span></span><br><span class="line"><span class="comment">c[i+1]=c[i]/10;</span></span><br><span class="line"><span class="comment">c[i]=c[i]%10;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">if(c[lc+1]&gt;0)  lc+=1;</span></span><br><span class="line"><span class="comment">repf(i,lc,1)  printf("%d",c[i]);</span></span><br><span class="line"><span class="comment">cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> as[<span class="number">1100</span>],bs[<span class="number">1100</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1100</span>],b[<span class="number">1100</span>],c[<span class="number">1100</span>],la,lb,lc,x;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cle(a); cle(b); cle(c);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,as,bs); <span class="comment">//用字符串读入两个加数  warning!!! 别用gets 会莫名爆错</span></span><br><span class="line">    la=<span class="built_in">strlen</span>(as); <span class="comment">//求长度</span></span><br><span class="line">    lb=<span class="built_in">strlen</span>(bs); </span><br><span class="line">    rep_(i,<span class="number">0</span>,la)  a[la-i]=as[i]-<span class="string">'0'</span>;  <span class="comment">//倒序储存</span></span><br><span class="line">    rep_(i,<span class="number">0</span>,lb)  b[lb-i]=bs[i]-<span class="string">'0'</span>;</span><br><span class="line">    lc=<span class="number">1</span>; x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(lc&lt;=la||lc&lt;=lb) <span class="comment">//相当于取两个加数中位数多的那一个</span></span><br><span class="line">    &#123;</span><br><span class="line">        c[lc]=a[lc]+b[lc]+x; <span class="comment">//当前位两数相加再加上上一位的进位</span></span><br><span class="line">        x=c[lc]/<span class="number">10</span>; <span class="comment">//处理当前位的进位</span></span><br><span class="line">        c[lc]%=<span class="number">10</span>; </span><br><span class="line">        lc++; <span class="comment">//下一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    c[lc]=x; <span class="comment">//最后一次进位即为第一位</span></span><br><span class="line">    <span class="keyword">if</span>(c[lc]==<span class="number">0</span>)  lc--; <span class="comment">//处理前导零</span></span><br><span class="line">    repf(i,lc,<span class="number">1</span>)  <span class="built_in">printf</span>(<span class="string">"%d"</span>,c[i]); <span class="comment">//倒序输出</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-高精度减法"><a href="#2-高精度减法" class="headerlink" title="2.高精度减法"></a>2.高精度减法</h4><p>几乎和高精度加法一样，需要判一下减数与被减数的大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> n[<span class="number">1000</span>],n1[<span class="number">1000</span>],n2[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000</span>],b[<span class="number">1000</span>],c[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> la,lb,lc;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cle(a); cle(b); cle(c);  <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,n1,n2);</span><br><span class="line">    la=<span class="built_in">strlen</span>(n1);</span><br><span class="line">    lb=<span class="built_in">strlen</span>(n2);</span><br><span class="line">    <span class="keyword">if</span>(la&lt;lb||(la==lb&amp;&amp;<span class="built_in">strcmp</span>(n1,n2)&lt;<span class="number">0</span>)) <span class="comment">//strcmp为字符串比较函数 此处处理输出负数的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(n,n1);  <span class="comment">//strcpy(a,b) 将b的内容覆盖到a上 此三句相当于交换</span></span><br><span class="line">        <span class="built_in">strcpy</span>(n1,n2);  </span><br><span class="line">        <span class="built_in">strcpy</span>(n2,n);</span><br><span class="line">        swap(la,lb);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"-"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">0</span>,la<span class="number">-1</span>)  a[la-i]=n1[i]-<span class="string">'0'</span>;</span><br><span class="line">    rep(i,<span class="number">0</span>,lb<span class="number">-1</span>)  b[lb-i]=n2[i]-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k&lt;=la||k&lt;=lb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[k]&lt;b[k])</span><br><span class="line">        &#123;</span><br><span class="line">            a[k]+=<span class="number">10</span>;  <span class="comment">//当前位向上一位借1</span></span><br><span class="line">            a[k+<span class="number">1</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        c[k]=a[k]-b[k];  <span class="comment">//当前位减一减</span></span><br><span class="line">        k++;  <span class="comment">//处理下一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    lc=k;  <span class="comment">//长度</span></span><br><span class="line">    <span class="keyword">while</span>((c[lc]==<span class="number">0</span>)&amp;&amp;(lc&gt;<span class="number">1</span>)) lc--; <span class="comment">//别忘了前导零</span></span><br><span class="line">    repf(i,lc,<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d"</span>,c[i]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-高精度乘法"><a href="#3-高精度乘法" class="headerlink" title="3.高精度乘法"></a>3.高精度乘法</h4><p>这个就要比前两个有难度了，因为竖式算乘法本身就模拟了第一个乘数乘以第二个乘数拆开来的各个位，而我们要做的就是倒序状态下模拟这个过程（其实把两个乘数都拆开了），简单地试一下后会发现乘积的i+j-1位即是第一个乘数第i位与第二个乘数第j位的乘积，然后就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> as[<span class="number">1100</span>],bs[<span class="number">1100</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1100</span>],b[<span class="number">1100</span>],c[<span class="number">1100</span>];</span><br><span class="line"><span class="keyword">int</span> la,lb,lc,x;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cle(a); cle(b); cle(c);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,as,bs);</span><br><span class="line">    la=<span class="built_in">strlen</span>(as);</span><br><span class="line">    lb=<span class="built_in">strlen</span>(bs);</span><br><span class="line">    rep_(i,<span class="number">0</span>,la) a[la-i]=as[i]-<span class="string">'0'</span>;</span><br><span class="line">    rep_(i,<span class="number">0</span>,lb) b[lb-i]=bs[i]-<span class="string">'0'</span>;</span><br><span class="line">  rep(i,<span class="number">1</span>,la)</span><br><span class="line">&#123;</span><br><span class="line">     x=<span class="number">0</span>;</span><br><span class="line">     rep(j,<span class="number">1</span>,lb) <span class="comment">//处理乘数的每一位</span></span><br><span class="line">     &#123;</span><br><span class="line">   c[i+j<span class="number">-1</span>]=a[i]*b[j]+x+c[i+j<span class="number">-1</span>];  <span class="comment">//当前位相乘+进位+乘积已有位上的数</span></span><br><span class="line">   x=c[i+j<span class="number">-1</span>]/<span class="number">10</span>;</span><br><span class="line">   c[i+j<span class="number">-1</span>]%=<span class="number">10</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     c[i+lb]=x;  <span class="comment">//进位</span></span><br><span class="line">&#125;</span><br><span class="line">lc=la+lb;</span><br><span class="line"><span class="keyword">while</span>(c[lc]==<span class="number">0</span>&amp;&amp;lc&gt;<span class="number">1</span>)  lc--;  <span class="comment">//删除前导0</span></span><br><span class="line">repf(i,lc,<span class="number">1</span>)  <span class="built_in">printf</span>(<span class="string">"%d"</span>,c[i]);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-高精度除法"><a href="#4-高精度除法" class="headerlink" title="4.高精度除法"></a>4.高精度除法</h4><p>坑先占着 这东西太烦 原来写的也找不到了 不写了</p>]]></content>
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>头文件</title>
      <link href="/2018/02/27/%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
      <url>/2018/02/27/%E5%A4%B4%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<blockquote><p>关键词: 头文件</p></blockquote><a id="more"></a><h3 id="头文件总结"><a href="#头文件总结" class="headerlink" title="头文件总结"></a>头文件总结</h3><blockquote><p>头文件这种东西，偷一下就行了对吧</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Williams Wu</span></span><br><span class="line"><span class="comment">/*#include &lt;EGE.h&gt;  //绘图头文件</span></span><br><span class="line"><span class="comment">#define SHOW_CONSOLE*/</span></span><br><span class="line"><span class="comment">/*#include &lt;cstdio&gt; //定义输入/输出函数</span></span><br><span class="line"><span class="comment">#include &lt;iostream&gt; //数据流输入/输出</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt; //STL通用算法</span></span><br><span class="line"><span class="comment">#include &lt;cmath&gt; //定义数学函数</span></span><br><span class="line"><span class="comment">#include &lt;cstdlib&gt; //定义杂项函数及内存分配函数</span></span><br><span class="line"><span class="comment">#include &lt;cstring&gt; //字符串处理</span></span><br><span class="line"><span class="comment">#include &lt;string&gt; //字符串类</span></span><br><span class="line"><span class="comment">#include &lt;ctime&gt; //定义关于时间的函数*/</span></span><br><span class="line"><span class="comment">/*#include &lt;bitset&gt; //STL位集容器</span></span><br><span class="line"><span class="comment">#include &lt;cstype&gt; //字符处理</span></span><br><span class="line"><span class="comment">#include &lt;cerrno&gt; //定义错误码</span></span><br><span class="line"><span class="comment">#include &lt;complex&gt; //复数类</span></span><br><span class="line"><span class="comment">#include &lt;clocale&gt; //定义本地化函数</span></span><br><span class="line"><span class="comment">#include &lt;deque&gt; //STL双端队列容器</span></span><br><span class="line"><span class="comment">#include &lt;exception&gt; //异常处理类</span></span><br><span class="line"><span class="comment">#include &lt;fstream&gt; //文件输入/输出</span></span><br><span class="line"><span class="comment">#include &lt;functional&gt; //STL定义运算函数(代替运算符)</span></span><br><span class="line"><span class="comment">#include &lt;limits&gt; //定义各种数据类型最值常量</span></span><br><span class="line"><span class="comment">#include &lt;list&gt; //STL线性列表容器</span></span><br><span class="line"><span class="comment">#include &lt;map&gt; //STL映射容器</span></span><br><span class="line"><span class="comment">#include &lt;iomanip&gt; //参数化输入/输出</span></span><br><span class="line"><span class="comment">#include &lt;ios&gt; //基本输入/输出支持</span></span><br><span class="line"><span class="comment">#include &lt;iosfwd&gt; //输入/输出系统使用的前置声明</span></span><br><span class="line"><span class="comment">#include &lt;istream&gt; //基本输入流</span></span><br><span class="line"><span class="comment">#include &lt;ostream&gt; //基本输出流</span></span><br><span class="line"><span class="comment">#include &lt;queue&gt; //STL队列容器</span></span><br><span class="line"><span class="comment">#include &lt;set&gt; //STL集合容器</span></span><br><span class="line"><span class="comment">#include &lt;sstream&gt; //基于字符串的流</span></span><br><span class="line"><span class="comment">#include &lt;stack&gt; //STL堆栈容器</span></span><br><span class="line"><span class="comment">#include &lt;stdexcept&gt; //标准异常类</span></span><br><span class="line"><span class="comment">#include &lt;streambuf&gt; //底层输入/输出支持</span></span><br><span class="line"><span class="comment">#include &lt;utility&gt; //STL通用模板类</span></span><br><span class="line"><span class="comment">#include &lt;vector&gt; //STL动态数组容器</span></span><br><span class="line"><span class="comment">#include &lt;cwchar.h&gt;//宽字符处理及输入/输出</span></span><br><span class="line"><span class="comment">#include &lt;cwctype.h&gt; //宽字符分类*/</span></span><br></pre></td></tr></table></figure><p>上面一部分是分开来的各类头文件，如果想偷懒的的可以使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(x,y,z) for (int x=(y);(x)&lt;=(z);(x)++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep_(x,y,z) for (int x=(y);(x)&lt;(z);(x)++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repf(x,y,z) for (int x=(y);(x)&gt;=(z);(x)--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repf_(x,y,z) for (int x=(y);(x)&gt;(z);(x)--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f  <span class="comment">//0x7fffffff</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clemin(x) memset(x,-1,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clemax(x) memset(x,0x3f,sizeof(x))  <span class="comment">//127</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br></pre></td></tr></table></figure><p>这一部分是各种宏定义，方便写程序，注意cle(x)表示清零，clemin()表示清成-1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const double PI =3.14159265358979323846264338327950288419716939937510;</span><br><span class="line">const double e=2.7182818284590452353602874713526624977572470936999596;</span><br><span class="line">const double eps = 0.000000001;</span><br></pre></td></tr></table></figure><p>定义一些常数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&gt;y?x:y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&lt;y?x:y;&#125;</span><br></pre></td></tr></table></figure><p>自己定义min和max，可以跑得快一点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////optimize//////////////////////////</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize("O2") //O2优化 </span></span><br><span class="line"><span class="comment">//#pragma GCC optimize("Ofast") //Ofast优化 </span></span><br><span class="line"><span class="comment">//ios::sync_with_stdio(false); //取消同步(加快流输入输出速度)</span></span><br></pre></td></tr></table></figure><p>Ofast和O2优化，还有取消同步 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////read///////////////////////////</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span></span>&#123;<span class="keyword">char</span> ch;x=<span class="number">0</span>;<span class="keyword">bool</span> flag=<span class="literal">false</span>;ch=getchar();<span class="keyword">while</span> (ch&gt;<span class="string">'9'</span>||ch&lt;<span class="string">'0'</span>)&#123;<span class="keyword">if</span> (ch==<span class="string">'-'</span>)flag=<span class="literal">true</span>;ch=getchar();&#125;<span class="keyword">while</span> ((ch&lt;=<span class="string">'9'</span>&amp;&amp;ch&gt;=<span class="string">'0'</span>)) &#123;x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>;ch=getchar();&#125;<span class="keyword">if</span>(flag)x*=<span class="number">-1</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x, T&amp; y)</span></span>&#123;read(x);read(y);&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x, T&amp; y, T&amp; z)</span></span>&#123;read(x);read(y);read(z);&#125;</span><br></pre></td></tr></table></figure><p>读入优化 为了偷懒还设置了可以一次读入2、3个的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/////////////////variables&amp;functions/////////////////////</span></span><br><span class="line">__attribute__((optimize(<span class="string">"Ofast"</span>),target(<span class="string">"no-ieee-fp,arch=amdfam10"</span>)))<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">xxx</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于加在int main前的那句话<br>我也不知道是干啥的<br>但是听说可以优化（和pragma差不多吧）<br>反正NOIP不允许用（笑</p>]]></content>
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 头文件 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
