<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[单源最短路]]></title>
    <url>%2F2018%2F09%2F04%2F%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[关键词: 单源最短路 单源最短路SPFA用数组dis记录起点到每个结点的最短路径用邻接表来存储图（邻接矩阵太浪费空间）用队列来保存待优化的结点（类似于BFS） 每次取出队首结点来进行松弛操作并更新最短路径如果要对所连点的最短路径需要更新，且点不在当前的队列中就将该点加入队列，然后不断进行松弛操作，直至队列为空为止。 1234567891011121314151617181920212223242526272829303132333435363738394041424344int first[10100],nxt[500100],u[500100],v[500100],w[500100],dis[10100];bool vis[10100];queue&lt;int&gt; que;int n,m,st;int main()&#123; read(n,m,st); //clemax(dis); rep(i,1,10099) dis[i]=2147483647; //注意 洛谷要求走不通输出2147483647 （mdzz dis[st]=0; clemin(first); rep(i,1,m) &#123; read(u[i],v[i],w[i]); nxt[i]=first[u[i]]; //建立邻接表 first[u[i]]=i; &#125; que.push(st); //一号顶点入队 cle(vis); vis[st]=1; //标记一号顶点已使用 while(!que.empty()) //队列不为空 &#123; int noww=first[que.front()]; //当前队列中第一个入队 while(noww!=-1) &#123; if(dis[v[noww]]&gt;dis[u[noww]]+w[noww]) //松弛边操作 &#123; dis[v[noww]]=dis[u[noww]]+w[noww]; if(!vis[v[noww]]) &#123; que.push(v[noww]); //被松弛顶点入队 vis[v[noww]]=1; //标记使用过 &#125; &#125; noww=nxt[noww]; //下一条边 &#125; vis[que.front()]=0; //顶点出队并取消标记(允许下一次进入) que.pop(); &#125; rep(i,1,n) printf("%d ",dis[i]); puts(""); return 0;&#125; Dijkstra 由于NOI2018 Day1T1的出题人成功把使用SPFA的选手卡成60分我们得出结论：SPFA死了！（笑 好吧 其实只是在考场上使用SPFA需要注意啦在毒瘤数据面前它可能退化到$O(nm)$的复杂度但是我们现在介绍的$Dijkstra$在无负边的情况下可以达到$O(nlogn)$且不会被卡这个算法是基于一个贪心的策略的老规矩，用数组$dis$记录起点到每个结点的最短路径从$dis$数组选择最小值，则该值就是源点$st$到该值对应的顶点的最短路径并且把该点记为已经找到最短路此时完成一个顶点再看这个点能否到达其它点，将$dis[noww]$的值进行更新不断重复上述动作，将所有的点都更新到最短路径 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849priority_queue&lt; pair&lt;LL,int&gt;, vector&lt;pair&lt;LL,int&gt; &gt;, greater&lt;pair&lt;LL,int&gt; &gt; &gt; que; //递增的优先队列，注意单调队列是根据pair的第一个元素来排列的，所以第一个元素放dis[]int head[500100],dis[100100];bool vis[100100];int n,m,st,cnt=0;struct edge&#123; int u,v,w,nxt;&#125;mapp[500100];inline void add(int u,int v,int w)&#123; mapp[++cnt].u=u; mapp[cnt].v=v; mapp[cnt].w=w; mapp[cnt].nxt=head[u]; //存储该点的下一条边 head[u]=cnt; //更新该点的最后一条边（也就是当前的边）&#125;int main()&#123; read(n,m,st); rep(i,1,m) &#123; int u,v,w; read(u,v,w); add(u,v,w); &#125; rep(i,1,n) dis[i]=2147483647; dis[st]=0; que.push(make_pair(0,st)); while(!que.empty()) //当堆不为空 &#123; int noww=que.top().second; que.pop(); //记录堆顶并将其弹出 if(!vis[noww]) //还没有遍历过 &#123; vis[noww]=1; for(int i=head[noww];i;i=mapp[i].nxt) //搜索堆顶所有连边 &#123; int tmp=mapp[i].v; dis[tmp]=min(dis[tmp],dis[noww]+mapp[i].w); //松弛操作 que.push(make_pair(dis[tmp],tmp)); &#125; &#125; &#125; rep(i,1,n) printf("%d ",dis[i]); return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求质数的方法]]></title>
    <url>%2F2018%2F08%2F29%2F%E6%B1%82%E8%B4%A8%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[关键词: 质数 求质数的方法第一类问题给出一个数。判断它是不是质数 $O(n)$的方法最最最最最朴素的判断质数法 1234567int is_prime(int n)&#123; rep_(i,2,n) if(n%i==0) return 0; return 1;&#125; $O(\sqrt{n})$的方法稍微优化了一下就可以了 1234567int is_prime(LL n)&#123; for(LL i=2;i*i&lt;=n;i++) if(n%i==0) return 0; return 1;&#125; Miller_Rabin素性测试尽管上面的$O(\sqrt{n})$的算法已经非常优秀了，但是面对更高数量级的“大数”却会显得力不从心。而这个时候，Miller_Rabin的优越性就显示出来了。 Miller_Rabin的理论基础来源于费马小定理。值得一提的是费马小定理是数论四大定理之一。 费马小定理：$n$是一个奇素数，$a$是任何整数$(1≤ a≤n-1)$ ，则 $a^{(n-1)} \equiv 1 (mod n)$ 要测试$n$是否是一个素数，首先将$n-1$分解为$(2^p) * tmp$，在每次测试开始时，先随机选择一个介于$[1, n - 1]$的整数$a$，计算出$a^{tmp}mod n$；算出来之后也不一定是素数，而是伪素数，再运用二项式探测定理，去检测：$x^2 \equiv 1(mod p)$，当$x_1=1$或$x_2=p-1$时成立。如果不符合，则是合数，如果符合，则有25%的概率为质数，那么经过$t$轮测试,$p$不是素数的概率为$\dfrac {1}{4^{t}}$，这也是为什么这个算法被称为素性测试了，它不能完全保证结果正确，而我们用2,3,5,7,11,13,17,192,3,5,7,11,13,17,19这些数进行判断，在信息学范围内基本上就不会出错了（笑 它的代码可以这么写： 1234567891011121314151617181920212223242526272829303132333435363738394041LL test[]=&#123;2,3,5,7,11,13,17,19&#125;;inline LL poww(LL a,LL p,LL MOD)&#123; LL res=1; while(p) &#123; if(p&amp;1) res=(res*a)%MOD; a=(a*a)%MOD; p&gt;&gt;=1; &#125; return res;&#125;inline bool mr_test(LL n)&#123; rep(i,0,7) if(n==test[i]) return 1; if((!(n&amp;1))||n==1) return 0; LL tmp=n-1,p=0; while(!(tmp&amp;1)) //把n-1拆分为2^p*tmp的形式 &#123; tmp&gt;&gt;=1; p++; &#125; rep(i,0,7) &#123; LL a=test[i]; //选择一个测试数 LL x=poww(a,tmp,n); //计算a^tmp mod n LL y=x; rep(j,1,p) &#123; y=(x*x)%n; if(y==1&amp;&amp;x!=1&amp;&amp;x!=n-1) return 0; //违背二次探测定理 为合数 x=y; &#125; if(x!=1) return 0; //最后算出的数不为1也是合数（费马小定理） &#125; return 1;&#125; 第二类问题求整数区间$[1,n]$的质数的个数和值我们遇到这种问题的时候一般用筛选法解答 埃拉托斯特尼筛法这个筛法的复杂度是$O(n log log n)$根据质数的整数倍一定不是质数的性质筛选即可 1234567891011121314151617181920212223//埃拉托斯特尼筛法bool vis[1000100];int n,cnt=0;int main()&#123; read(n); cle(vis); vis[1]=1; //1是素数 rep(i,2,sqrt(n)) //只需要算到sqrt(n)就行了 if(vis[i]==0) //当前数是素数 for(int j=2;j*i&lt;=n;j++) //素数的整数倍不是素数 vis[i*j]=1; //标记 rep(i,1,n) if(vis[i]==0) /*&#123; cnt++;*/ printf("%d ",i); //&#125; puts(""); //printf("%d\n",cnt); return 0;&#125; 欧拉筛 这就是大名鼎鼎的线性复杂度的欧拉筛显然我们会发现用埃氏筛法的时候有些合数被筛了不止一次所以在欧拉筛中我们针对此进行了优化保证每个合数只会被它的最小质因数筛去因此每个数只会被筛一次那么复杂度就可以了到达$O(n)$了！ 1234567891011121314151617181920212223242526//欧拉筛法int prime[10000100];bool vis[10000100];int n,cnt=0;int main()&#123; read(n); cle(vis); cle(prime); rep(i,2,n) &#123; if(!vis[i]) prime[cnt++]=i; for(int j=0;j&lt;cnt&amp;&amp;i*prime[j]&lt;=n;j++) &#123; vis[i*prime[j]]=1; //已经找到的素数的倍数 if(i%prime[j]==0) break; //因为prime[j]*k=i 所以i*prime[j+1]=prime[j]*(k*prime[j+1]) //所以必定会被prime[j]筛掉 而prime[]是递增的 那么就不需要再筛了 &#125; &#125; rep_(i,0,cnt) printf("%d ",prime[i]); puts(""); //printf("%d\n",cnt); return 0; &#125; Meissel-Lehmer算法暂时还不会，坑先占着。]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速读入]]></title>
    <url>%2F2018%2F08%2F29%2F%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%85%A5%2F</url>
    <content type="text"><![CDATA[关键词: 快速读入 快速读入普通的读入优化因为getchar()的速度远快于scanf或是cin，所以我们就想到利用getchar()一个一个读入字符然后把它转化为原来类型的变量就可以了，然后优化了一下，方便读入多个变量。 12345678template &lt;typename T&gt;inline void read(T&amp; x)&#123;char id;x=0;bool flag=false;id=getchar(); while(id&gt;'9'||id&lt;'0')&#123;if(id=='-')flag=true;id=getchar();&#125; while((id&lt;='9'&amp;&amp;id&gt;='0')) &#123;x=x*10+id-'0';id=getchar();&#125;if(flag)x*=-1;&#125;template &lt;typename T&gt;inline void read(T&amp; x,T&amp; y)&#123;read(x);read(y);&#125;template &lt;typename T&gt;inline void read(T&amp; x,T&amp; y,T&amp; z)&#123;read(x);read(y);read(z);&#125; 利用fread的读入优化在有些毒瘤题出现的时候，因为读入量是在太大，连getchar()都过不去，那么我们想到利用fread一次把所有的输入都读完，然后在buf[]数组里一个一个取出来，就完成了读入，但是要注意fread会把所有输入都读完，所以之后就不要再用其他读入了（上次就因为这个炸了好几发 嘤嘤嘤）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253namespace fast_IO&#123; inline char read() &#123; static const int IN_LEN=1000000; static char buf[IN_LEN],*s,*t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++); &#125; template&lt;class T&gt; inline void read(T &amp;x) &#123; static bool iosig; static char c; for(iosig=false,c=read();!isdigit(c);c=read()) &#123; if(c=='-') iosig=1; if(c==-1) return; &#125; for(x=0;isdigit(c);c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if(iosig) x=-x; &#125; const int OUT_LEN=10000000; char obuf[OUT_LEN],*ooh=obuf; inline void print(char c) &#123; if(ooh==obuf+OUT_LEN) &#123; fwrite(obuf,1,OUT_LEN,stdout); ooh=obuf; &#125; *ooh++=c; &#125; template&lt;class T&gt; inline void print(T x) &#123; static int buf[30],cnt; if(x==0) print('0'); else &#123; if(x&lt;0) &#123; print('-'); x=-x; &#125; for(cnt=0;x;x/=10) buf[++cnt]=x%10+48; while(cnt) print((char)buf[cnt--]); &#125; &#125; inline void flush()&#123; fwrite(obuf,1,ooh-obuf,stdout); &#125;&#125;using namespace fast_IO;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>头文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乘法逆元]]></title>
    <url>%2F2018%2F05%2F28%2F%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%2F</url>
    <content type="text"><![CDATA[关键词: 乘法逆元 乘法逆元定义满足 $b \times k ≡ 1 (mod p)$的$k$的值就是$b$关于$p$的乘法逆元。这里我们只讨论当模数$p$为素数的情况，因为如果模数不为素数，则不一定每个数都有逆元。 应用乘法逆元一大重要应用就是模意义下的除法因为$(a \div b) mod p \neq a mod p+b mod p $所以当我们要求$(a \div b) mod p$的值，且$a$很大，无法直接求得$a \div b$的值时，我们就要用到乘法逆元。 欧几里得最大公约数 gcd$gcd(a,b)=\left \{ a \qquad \qquad \quad b=0 \atop gcd(b,a \, mod \, b ) \quad b \neq 0\right.$代码：123int gcd(int a,int b)&#123; return !b?a:gcd(b,a%b);&#125; 最小公倍数 lcm而两数相乘除以最大公约数即为最小公倍数$lcm(a,b)=\left \{ {\frac{a \times b}{gcd(a.b)}} \right.$代码：123int lcm(int a,int b)&#123; return a/gcd(a,b)*b; //注意先除后乘防爆int&#125; 扩展欧几里得扩展欧几里得 exgcd 可以在$O(log max(a, b))$的复杂度内求出$gcd(a,b)$的同时求出二元一次不定方程 $ax+by=gcd(a,b)$的一组整数解。 $eg:$ 求$gcd(47,30)$通过欧几里得我们可以得到以下式子：$47\div30=1…17$$30\div17=1…13$$17\div13=1…4$$13\div4=3…1$ 把余数移到一边$17=47+30\times(-1)$$13=30+17\times(-1)$$4=17+13\times(-1)$$1=13+4\times(-3)$ 从 $gcd(47,30)=1$ 开始，将四个式子依次带入，得$gcd(47,30)$$=1$$=13\times1+4\times(-3)$$=13\times1+(17+13\times(-1))\times(-3)$$=13\times4+17\times(-3)$$=(30+17\times(-1))\times4+17\times(-3)$$=17\times(-7)+30\times4$$=(47+30\times(-1))\times(-7)+30\times4$$=47\times(-7)+30\times11$ $So$ 解得 $x=-7,y=11$。 由上述式子可观察到，每次辗转交换了$x$和$y$，并将$y$减去了原$x$与辗转相除所得商的乘积。 代码：1234567891011121314void exgcd(int a,int b,int g,int &amp;x,int &amp;y)&#123; if(b==0) &#123; x=1; y=0; g=a; &#125; else &#123; exgcd(b,a%b,g,y,x); y-=x*(a/b); &#125;&#125; 扩展欧几里得求乘法逆元用扩展欧几里得求逆元要求 $gcd(b, p) =1$ 我们可以通过求$b$关于$p$的乘法逆元$k$，再求 $(a \times k) mod p$。其结果与$(a \div b) mod p$等价。 证明:因为 $b \times k ≡ 1 (mod p)$则有 $b \times k = p \times x+1$得到 $k = (p \times x + 1) \div b$将 $k$ 代入$(a \times k) mod p$得到：$((p \times x + 1) \times a \div b) mod p$$=(p \times x \times a \div b + a \div b) mod p$$=[(a \times p \times x \div b) mod p +(a \div b) mod p] mod p$$=[(p \times (a \times x \div b)) mod p +(a \div b) mod p] mod p$$= (a \div b) mod p$ 代码1234567891011121314151617181920void exgcd(const int a,const int b,int &amp;g,int &amp;x,int &amp;y)&#123; if(b==0) &#123; g=a; x=1; y=0; &#125; else &#123; exgcd(b,a%b,g,y,x); y-=x*(a/b); &#125;&#125;inline int inv(const int num) &#123; int g,x,y; exgcd(num,mod,g,x,y); return ((x%mod)+mod)%mod;&#125; 费马小定理求乘法逆元费马小定理：$a^{p-1}≡1 (mod p)$ ($p$为质数)变形可得：$a \times a^{p-2}≡1 (mod p)$由定义可以知道$a^{p-2}$即为$a$的乘法逆元 利用快速幂计算$a^{p-2}$ 所以总复杂度是$O(log a)$ 我觉得还是比较慢的 好像比较容易T掉 代码：1234567891011inline int pow(const int n,const int k) &#123; LL ans=1; for(LL num=n,t=k;t;num=num*num%MOD,t&gt;&gt;=1) if(t&amp;1) ans=ans*num%MOD; return ans;&#125;inline int inv(const int num)&#123; return pow(num,MOD-2);&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[treap]]></title>
    <url>%2F2018%2F05%2F12%2Ftreap%2F</url>
    <content type="text"><![CDATA[关键词: treap Treap Treap是一个优先值域满足堆的性质的二叉搜索树 建树时随机给每个节点赋随机优先值 要求 节点的优先值域满足堆的性质 &amp;&amp;节点的值满足二叉搜索树的性质 小知识普及 二叉查找树(Binary Search Tree)或者是一棵空树，或者是具有下列性质的二叉树 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉查找树。 故中序遍历二叉搜索树即可得到有序序列 前序遍历 根左右 在本图即为ABDECF中序遍历 左根右 DBEAFC后序遍历 左右根 DEBFCA 时间复杂度分析 每个操作期望复杂度都为O(log n) 插入：由于期望树高h为log n 插入操作是将待插入点放入叶节点并不断按要求旋转 （跟维护堆一样，如果当前节点的优先级比根大就旋转，如果当前节点是根的左儿子就右旋如果当前节点是根的右儿子就左旋。） 故最多进行复杂度为O(1)的旋转操作h次 删除：同理插入 删除是把待删除节点转到叶节点上然后直接删除即可 （每次找到优先级最大的儿子，向与其相反的方向旋转） 故最多也是进行h次旋转操作 查找：由于treap是二叉搜索树 但是是随机化结构 故期望O(log n) 分离： 要把一个Treap按大小分成两个Treap，只要在需要分开的位置加一个虚拟节点，然后旋至根节点删除，左右两个子树就是得出的两个Treap。 而根据二叉搜索树的性质，这时左子树的所有节点都小于右子树的节点。 合并： 合并两棵平衡树的条件正好是上方分离操作的结果 要求其中第一棵树的所有节点都必须小于或等于第二棵树中的所有节点 所以操作过程也正好与分离相反 只需要加一个虚拟的根，把两棵树分别作为左右子树，然后删除根即可 查找排名第 k 的元素 在一棵二叉搜索树中，根节点的排名取决于其左子树的大小 而我们知道treap的子树还是treap 由于节点有重复 所以如果当前节点P满足P.left.size&lt;=k&lt;=P.left.size+P.weight 那么P就是排名第K的元素 若满足 k &lt; P.left.size + 1，则在左子树中查找排名第 k 的元素； 若满足 k &gt; P.left.size + P.weight，则在右子树中查找排名第 k-(P.left.size + P.weight)的元素。 排名 如果没有重复元素 那么此操作与查找排名第 k 的元素为严格的逆运算 cur为当前已知的比要求的元素小的元素个数 当前节点等于目标 排名为P.left.size + cur + 1 （有重复的排名取最小） 当前节点大于目标，在左子树中查找排名； 当前元素小于目标，更新 cur 为 cur + P.left.size+weight，在右子树中查找排名 基本动作 旋转左旋 (A节点) 获取根节点A的右儿子节点B 将节点B的父亲节点信息更新为f （双向） 将节点A的右儿子信息更新为节点B的左儿子D （双向） 将节点B的左儿子信息更改为节点A （双向） 代码1(有父亲节点域的)：12345678910111213141516171819void LTURN(int u) //左旋&#123; treap[treap[u].pre].r=treap[u].l; treap[treap[u].l].pre=treap[u].pre; //将u的父亲作为u的左儿子的父亲 int tmp=treap[treap[u].pre].pre; treap[u].l=treap[u].pre; treap[treap[u].pre].pre=u; //将u作为与u的父亲的父亲 treap[u].pre=tmp; //将原来根节点的上继节点赋给新的根节点（也就是要旋转的u） if(tmp!=0) //如果根节点的上继节点不为0 &#123; if(treap[u].value&lt;treap[tmp].value) treap[tmp].l=u; //将根节点赋为根节点的上继节点的左儿子 else treap[tmp].r=u; //（同上）右儿子 &#125; else //根节点的上继节点为0 &#123; root=u; //u为正式的根节点 //treap[root].pre=0; //正式把根节点的上继节点赋为0 &#125;&#125; 代码2(无父亲节点域的)：123456789void lturn(int &amp;k) //由于没有父亲域 所以不需要双向改动&#123; int tmp=treap[k].r; //tmp即为将来根 treap[k].r=treap[tmp].l; //改变目前根的右节点为将来根的左节点 treap[tmp].l=k; //改变将来根的左节点为目前根 treap[tmp].size=treap[k].size; //更新将来根的节点数 update(k); //更新目前根的节点数 k=tmp; //改变根&#125; 右旋 (A节点)操作为左旋的镜像 获取根节点A的左儿子节点B 将节点B的父亲节点信息更新为f （双向） 将节点A的左儿子信息更新为节点B的右儿子D （双向） 将节点B的右儿子信息更改为节点A （双向） 代码1：12345678910111213141516171819void RTURN(int u) //右旋 操作同左旋&#123; treap[treap[u].pre].l=treap[u].r; treap[treap[u].r].pre=treap[u].pre; int tmp=treap[treap[u].pre].pre; treap[u].r=treap[u].pre; treap[treap[u].pre].pre=u; treap[u].pre=tmp; if(tmp!=0) &#123; if(treap[u].value&lt;treap[tmp].value) treap[tmp].l=u; else treap[tmp].r=u; &#125; else &#123; root=u; //treap[root].pre=0; &#125;&#125; 123456789void rturn(int &amp;k) //同理左旋&#123; int tmp=treap[k].l; treap[k].l=treap[tmp].r; treap[tmp].r=k; treap[tmp].size=treap[k].size; update(k); k=tmp;&#125; 模板代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157//Williams Wustruct node&#123; int l,r,value,rnd,amount,size; //左右儿子 值 随机的优先值 //.amount为某个值多次出现的个数 用来代替重复的节点 //.size为以当前节点为根的子树大小 是查询排名的必备 在删除 旋转 插入时都会改变&#125;;node treap[100005];int n,size,root,ans;void update(int k)&#123; //更新结点信息 treap[k].size=treap[treap[k].l].size+treap[treap[k].r].size+treap[k].amount; //一个节点的路径数等于左右儿子路径数与节点数值重复次数之和&#125;void lturn(int &amp;k) //由于没有父亲域 所以不需要双向改动&#123; int tmp=treap[k].r; //tmp即为将来根 treap[k].r=treap[tmp].l; //改变目前根的右节点为将来根的左节点 treap[tmp].l=k; //改变将来根的左节点为目前根 treap[tmp].size=treap[k].size; //更新将来根的节点数 update(k); //更新目前根的节点数 k=tmp; //改变根&#125;void rturn(int &amp;k) //同理左旋&#123; int tmp=treap[k].l; treap[k].l=treap[tmp].r; treap[tmp].r=k; treap[tmp].size=treap[k].size; update(k); k=tmp;&#125;void insert(int &amp;k,int x)&#123; if(k==0) &#123; k=++size; treap[k].size=treap[k].amount=1; treap[k].value=x; treap[k].rnd=rand(); return; &#125; //插入叶子结点 treap[k].size++; //每经过一个节点，都要先使以它为根的子树的大小增加 1，再递归进入子树查找 if(treap[k].value==x) treap[k].amount++; else if(x&gt;treap[k].value) //应在根的右边 &#123; insert(treap[k].r,x); //继续用根节点的右儿子搜索 if(treap[treap[k].r].rnd&lt;treap[k].rnd) lturn(k); //维护完二叉搜索树的性质后开始维护堆的性质（旋转） &#125; else &#123; insert(treap[k].l,x); //左儿子 if(treap[treap[k].l].rnd&lt;treap[k].rnd)rturn(k); //右旋 &#125;&#125;void del(int &amp;k,int x)&#123; if(k==0) return; //已到叶子结点 可以删除 if(treap[k].value==x) &#123; if(treap[k].amount&gt;1) //如果该节点不止一个 重复数量减掉一个即可 &#123; treap[k].amount--; treap[k].size--; //子树大小减1 return; &#125; if(treap[k].l*treap[k].r==0) k=treap[k].l+treap[k].r; //如果左右节点中有任何一个是叶子结点 直接替换当前根 else if(treap[treap[k].l].rnd&lt;treap[treap[k].r].rnd) //左子树的随机值比右子树小 &#123; rturn(k); //右旋 del(k,x); //继续讨论 &#125; else //反之亦然 &#123; lturn(k); del(k,x); &#125; &#125; else if(x&gt;treap[k].value) &#123; treap[k].size--; //递归返回时要把所有的经过的节点的子树的大小减1。注意 删除前要保证待删除节点存在于树中 del(treap[k].r,x); &#125; else &#123; treap[k].size--; del(treap[k].l,x); &#125;&#125;int ranknum(int k,int x)&#123; if(k==0) return 0; if(treap[k].value==x) return treap[treap[k].l].size+1; //左子树全部比根小 else if(x&gt;treap[k].value) return treap[treap[k].l].size+treap[k].amount+ranknum(treap[k].r,x); //注意要加上重复的个数 else return ranknum(treap[k].l,x);&#125;int rerank(int k,int x)//根据二叉搜索树的性质 根节点的rank取决于其左子树的大小&#123; if(k==0) return 0; if(x&lt;=treap[treap[k].l].size) return rerank(treap[k].l,x); else if(x&gt;treap[treap[k].l].size+treap[k].amount) //注意当前节点可能有多个重复的 return rerank(treap[k].r,x-treap[treap[k].l].size-treap[k].amount); else return treap[k].value;&#125;void provalue(int k,int x) //注意定义 小于/不大于&#123; if(k==0)return; //当前节点为空节点 查找结束 最优节点ans即为所求 if(treap[k].value&lt;x) //当前元素小于目标 &#123; ans=k; //更新最优节点 provalue(treap[k].r,x); //并访问当前节点的右儿子 &#125; else provalue(treap[k].l,x); //不满足条件 访问当前节点的左儿子&#125;void nextvalue(int k,int x)&#123; if(k==0)return; if(treap[k].value&gt;x) &#123; ans=k; nextvalue(treap[k].l,x); &#125; else nextvalue(treap[k].r,x);&#125;int main()&#123; read(n); int opt,x; rep(i,1,n) &#123; read(opt,x); switch(opt) &#123; case 1:insert(root,x); break; //插入 case 2:del(root,x); break; //删除 case 3:printf("%d\n",ranknum(root,x)); break; //排名 case 4:printf("%d\n",rerank(root,x)); break; //排名反向 case 5:ans=0;provalue(root,x); printf("%d\n",treap[ans].value);break; //前驱（小于的max） case 6:ans=0;nextvalue(root,x); printf("%d\n",treap[ans].value);break; //后继（大于的min） &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>高级数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高精度]]></title>
    <url>%2F2018%2F03%2F01%2F%E9%AB%98%E7%B2%BE%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[关键词: 高精度 高精度总结 高精度这种基础知识还是需要复习一下的，所以干脆来总结一下 1.高精度加法就是模拟竖式，处理一下进位就好了，需要注意读入的时候用scanf()比较保险，别乱用gets，还有就是加完前导零需要处理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455头文件省略//另一种写法/*char as[11001],bs[11001];int a[11001],b[11001],c[11002];int la,lb,lc;int main()&#123; cle(a); cle(b); cle(c); scanf("%s%s",as,bs); la=strlen(as); lb=strlen(bs); rep_(i,0,la) a[i+1]=as[i]-'0'; rep_(i,0,lb) b[i+1]=bs[i]-'0'; rep(i,1,la/2) swap(a[i],a[la-i+1]); rep(i,1,lb/2) swap(b[i],b[lb-i+1]); if(la&gt;lb) lc=la; else lc=lb; rep(i,1,lc) &#123; c[i]=c[i]+a[i]+b[i]; c[i+1]=c[i]/10; c[i]=c[i]%10; &#125; if(c[lc+1]&gt;0) lc+=1; repf(i,lc,1) printf("%d",c[i]); cout&lt;&lt;endl; return 0;&#125;*/char as[1100],bs[1100];int a[1100],b[1100],c[1100],la,lb,lc,x;int main()&#123; cle(a); cle(b); cle(c); scanf("%s%s",as,bs); //用字符串读入两个加数 warning!!! 别用gets 会莫名爆错 la=strlen(as); //求长度 lb=strlen(bs); rep_(i,0,la) a[la-i]=as[i]-'0'; //倒序储存 rep_(i,0,lb) b[lb-i]=bs[i]-'0'; lc=1; x=0; while(lc&lt;=la||lc&lt;=lb) //相当于取两个加数中位数多的那一个 &#123; c[lc]=a[lc]+b[lc]+x; //当前位两数相加再加上上一位的进位 x=c[lc]/10; //处理当前位的进位 c[lc]%=10; lc++; //下一位 &#125; c[lc]=x; //最后一次进位即为第一位 if(c[lc]==0) lc--; //处理前导零 repf(i,lc,1) printf("%d",c[i]); //倒序输出 cout&lt;&lt;endl; return 0;&#125; 2.高精度减法几乎和高精度加法一样，需要判一下减数与被减数的大小 123456789101112131415161718192021222324252627282930313233343536char n[1000],n1[1000],n2[1000];int a[1000],b[1000],c[1000];int la,lb,lc;int main()&#123; cle(a); cle(b); cle(c); //初始化 scanf("%s%s",n1,n2); la=strlen(n1); lb=strlen(n2); if(la&lt;lb||(la==lb&amp;&amp;strcmp(n1,n2)&lt;0)) //strcmp为字符串比较函数 此处处理输出负数的情况 &#123; strcpy(n,n1); //strcpy(a,b) 将b的内容覆盖到a上 此三句相当于交换 strcpy(n1,n2); strcpy(n2,n); swap(la,lb); cout&lt;&lt; "-"; &#125; rep(i,0,la-1) a[la-i]=n1[i]-'0'; rep(i,0,lb-1) b[lb-i]=n2[i]-'0'; int k=1; while(k&lt;=la||k&lt;=lb) &#123; if(a[k]&lt;b[k]) &#123; a[k]+=10; //当前位向上一位借1 a[k+1]--; &#125; c[k]=a[k]-b[k]; //当前位减一减 k++; //处理下一位 &#125; lc=k; //长度 while((c[lc]==0)&amp;&amp;(lc&gt;1)) lc--; //别忘了前导零 repf(i,lc,1) printf("%d",c[i]); cout&lt;&lt;endl; return 0;&#125; 3.高精度乘法这个就要比前两个有难度了，因为竖式算乘法本身就模拟了第一个乘数乘以第二个乘数拆开来的各个位，而我们要做的就是倒序状态下模拟这个过程（其实把两个乘数都拆开了），简单地试一下后会发现乘积的i+j-1位即是第一个乘数第i位与第二个乘数第j位的乘积，然后就好了。 12345678910111213141516171819202122232425262728char as[1100],bs[1100];int a[1100],b[1100],c[1100];int la,lb,lc,x;int main()&#123; cle(a); cle(b); cle(c); scanf("%s%s",as,bs); la=strlen(as); lb=strlen(bs); rep_(i,0,la) a[la-i]=as[i]-'0'; rep_(i,0,lb) b[lb-i]=bs[i]-'0'; rep(i,1,la) &#123; x=0; rep(j,1,lb) //处理乘数的每一位 &#123; c[i+j-1]=a[i]*b[j]+x+c[i+j-1]; //当前位相乘+进位+乘积已有位上的数 x=c[i+j-1]/10; c[i+j-1]%=10; &#125; c[i+lb]=x; //进位 &#125; lc=la+lb; while(c[lc]==0&amp;&amp;lc&gt;1) lc--; //删除前导0 repf(i,lc,1) printf("%d",c[i]); cout&lt;&lt;endl; return 0;&#125; 4.高精度除法坑先占着 这东西太烦 原来写的也找不到了 不写了]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[头文件]]></title>
    <url>%2F2018%2F02%2F27%2F%E5%A4%B4%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[关键词: 头文件 头文件总结 头文件这种东西，偷一下就行了对吧 1234567891011121314151617181920212223242526272829303132333435363738//Williams Wu/*#include &lt;EGE.h&gt; //绘图头文件#define SHOW_CONSOLE*//*#include &lt;cstdio&gt; //定义输入/输出函数#include &lt;iostream&gt; //数据流输入/输出#include &lt;algorithm&gt; //STL通用算法#include &lt;cmath&gt; //定义数学函数#include &lt;cstdlib&gt; //定义杂项函数及内存分配函数#include &lt;cstring&gt; //字符串处理#include &lt;string&gt; //字符串类#include &lt;ctime&gt; //定义关于时间的函数*//*#include &lt;bitset&gt; //STL位集容器#include &lt;cstype&gt; //字符处理#include &lt;cerrno&gt; //定义错误码#include &lt;complex&gt; //复数类#include &lt;clocale&gt; //定义本地化函数#include &lt;deque&gt; //STL双端队列容器#include &lt;exception&gt; //异常处理类#include &lt;fstream&gt; //文件输入/输出#include &lt;functional&gt; //STL定义运算函数(代替运算符)#include &lt;limits&gt; //定义各种数据类型最值常量#include &lt;list&gt; //STL线性列表容器#include &lt;map&gt; //STL映射容器#include &lt;iomanip&gt; //参数化输入/输出#include &lt;ios&gt; //基本输入/输出支持#include &lt;iosfwd&gt; //输入/输出系统使用的前置声明#include &lt;istream&gt; //基本输入流#include &lt;ostream&gt; //基本输出流#include &lt;queue&gt; //STL队列容器#include &lt;set&gt; //STL集合容器#include &lt;sstream&gt; //基于字符串的流#include &lt;stack&gt; //STL堆栈容器#include &lt;stdexcept&gt; //标准异常类#include &lt;streambuf&gt; //底层输入/输出支持#include &lt;utility&gt; //STL通用模板类#include &lt;vector&gt; //STL动态数组容器#include &lt;cwchar.h&gt;//宽字符处理及输入/输出#include &lt;cwctype.h&gt; //宽字符分类*/ 上面一部分是分开来的各类头文件，如果想偷懒的的可以使用 1#include &lt;bits/stdc++.h&gt; 12345678910using namespace std;#define rep(x,y,z) for (int x=(y);(x)&lt;=(z);(x)++)#define rep_(x,y,z) for (int x=(y);(x)&lt;(z);(x)++)#define repf(x,y,z) for (int x=(y);(x)&gt;=(z);(x)--)#define repf_(x,y,z) for (int x=(y);(x)&gt;(z);(x)--)#define inf 0x3f3f3f3f //0x7fffffff#define cle(x) memset(x,0,sizeof(x))#define clemin(x) memset(x,-1,sizeof(x))#define clemax(x) memset(x,0x3f,sizeof(x)) //127typedef long long LL; 这一部分是各种宏定义，方便写程序，注意cle(x)表示清零，clemin()表示清成-1 123const double PI =3.14159265358979323846264338327950288419716939937510;const double e=2.7182818284590452353602874713526624977572470936999596;const double eps = 0.000000001; 定义一些常数 12int max(int x,int y)&#123;return x&gt;y?x:y;&#125;int min(int x,int y)&#123;return x&lt;y?x:y;&#125; 自己定义min和max，可以跑得快一点 1234///////////////////////optimize////////////////////////////#pragma GCC optimize("O2") //O2优化 //#pragma GCC optimize("Ofast") //Ofast优化 //ios::sync_with_stdio(false); //取消同步(加快流输入输出速度) Ofast和O2优化，还有取消同步 1234567//////////////////////////read///////////////////////////template &lt;typename T&gt;inline void read(T&amp; x)&#123;char ch;x=0;bool flag=false;ch=getchar();while (ch&gt;'9'||ch&lt;'0')&#123;if (ch=='-')flag=true;ch=getchar();&#125;while ((ch&lt;='9'&amp;&amp;ch&gt;='0')) &#123;x=x*10+ch-'0';ch=getchar();&#125;if(flag)x*=-1;&#125;template &lt;typename T&gt;inline void read(T&amp; x, T&amp; y)&#123;read(x);read(y);&#125;template &lt;typename T&gt;inline void read(T&amp; x, T&amp; y, T&amp; z)&#123;read(x);read(y);read(z);&#125; 读入优化 为了偷懒还设置了可以一次读入2、3个的 123456/////////////////variables&amp;functions/////////////////////__attribute__((optimize("Ofast"),target("no-ieee-fp,arch=amdfam10")))int main()&#123; xxx return 0;&#125; 至于加在int main前的那句话我也不知道是干啥的但是听说可以优化（和pragma差不多吧）反正NOIP不允许用（笑]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>头文件</tag>
      </tags>
  </entry>
</search>
