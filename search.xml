<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>treap</title>
      <link href="/2018/05/12/treap/"/>
      <url>/2018/05/12/treap/</url>
      <content type="html"><![CDATA[<blockquote><p>关键词: treap </p></blockquote><a id="more"></a><h2 id="Treap"><a href="#Treap" class="headerlink" title="Treap"></a>Treap</h2><p>  Treap是一个优先值域满足堆的性质的二叉搜索树<br>  建树时随机给每个节点赋随机优先值<br>  要求 节点的优先值域满足堆的性质 &amp;&amp;节点的值满足二叉搜索树的性质</p><h3 id="小知识普及"><a href="#小知识普及" class="headerlink" title="小知识普及"></a>小知识普及</h3><p>  二叉查找树(Binary Search Tree)或者是一棵空树，或者是具有下列性质的二叉树</p><ol><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li><p>它的左、右子树也分别为二叉查找树。</p><p>故中序遍历二叉搜索树即可得到有序序列</p><p>前序遍历 根左右 在本图即为ABDECF<br>中序遍历 左根右 DBEAFC<br>后序遍历 左右根 DEBFCA<br><img src="https://s1.ax1x.com/2018/05/11/C0UQ8e.png" alt="简单的二叉树"></p></li></ol><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>  每个操作<strong>期望</strong>复杂度都为O(log n)</p><p>  <strong><em>插入</em></strong>：由于期望树高h为log n<br>  插入操作是将待插入点放入叶节点并不断按要求旋转<br>  （跟维护堆一样，如果当前节点的优先级比根大就旋转，如果当前节点是根的左儿子就右旋如果当前节点是根的右儿子就左旋。）<br>  故最多进行复杂度为O(1)的旋转操作h次</p><p>  <strong><em>删除</em></strong>：同理插入<br>  删除是把待删除节点转到叶节点上然后直接删除即可<br>  （每次找到优先级最大的儿子，向与其相反的方向旋转）<br>  故最多也是进行h次旋转操作</p><p>  <strong><em>查找</em></strong>：由于treap是二叉搜索树 但是是随机化结构<br>  故期望O(log n)</p><p>  <strong><em>分离</em></strong>： 要把一个Treap按大小分成两个Treap，只要在需要分开的位置加一个虚拟节点，然后旋至根节点删除，左右两个子树就是得出的两个Treap。<br>  而根据二叉搜索树的性质，这时左子树的所有节点都小于右子树的节点。 </p><p>  <strong><em>合并</em></strong>： 合并两棵平衡树的条件正好是上方分离操作的结果<br>  要求其中第一棵树的所有节点都必须小于或等于第二棵树中的所有节点<br>  所以操作过程也正好与分离相反<br>  只需要加一个虚拟的根，把两棵树分别作为左右子树，然后删除根即可</p><p>  <strong><em>查找排名第 k 的元素</em></strong>  在一棵二叉搜索树中，根节点的排名取决于其左子树的大小<br>  而我们知道treap的子树还是treap 由于节点有重复 所以如果当前节点P满足P.left.size&lt;=k&lt;=P.left.size+P.weight  那么P就是排名第K的元素<br>   若满足 k &lt; P.left.size + 1，则在左子树中查找排名第 k 的元素；<br>   若满足 k &gt; P.left.size + P.weight，则在右子树中查找排名第 k-(P.left.size + P.weight)的元素。</p><p>  <strong><em>排名</em></strong> 如果没有重复元素 那么此操作与查找排名第 k 的元素为严格的逆运算<br>  cur为当前已知的比要求的元素小的元素个数<br>  当前节点等于目标 排名为P.left.size + cur + 1  （有重复的排名取最小）<br>  当前节点大于目标，在左子树中查找排名；<br>  当前元素小于目标，更新 cur 为 cur + P.left.size+weight，在右子树中查找排名</p><h3 id="基本动作-旋转"><a href="#基本动作-旋转" class="headerlink" title="基本动作 旋转"></a>基本动作 旋转</h3><p><img src="https://s1.ax1x.com/2018/05/11/C0yna9.png" alt="enter image description here"><br><strong><em>左旋</em></strong>    (A节点)</p><ol><li>获取根节点A的右儿子节点B</li><li>将节点B的父亲节点信息更新为f （双向）</li><li>将节点A的右儿子信息更新为节点B的左儿子D （双向）</li><li>将节点B的左儿子信息更改为节点A （双向）</li></ol><p>代码1(有父亲节点域的)：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LTURN</span><span class="params">(<span class="keyword">int</span> u)</span>  <span class="comment">//左旋</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    treap[treap[u].pre].r=treap[u].l;</span><br><span class="line">    treap[treap[u].l].pre=treap[u].pre;  <span class="comment">//将u的父亲作为u的左儿子的父亲</span></span><br><span class="line">    <span class="keyword">int</span> tmp=treap[treap[u].pre].pre;  </span><br><span class="line">    treap[u].l=treap[u].pre;</span><br><span class="line">    treap[treap[u].pre].pre=u;  <span class="comment">//将u作为与u的父亲的父亲</span></span><br><span class="line">    treap[u].pre=tmp;  <span class="comment">//将原来根节点的上继节点赋给新的根节点（也就是要旋转的u）</span></span><br><span class="line">    <span class="keyword">if</span>(tmp!=<span class="number">0</span>)  <span class="comment">//如果根节点的上继节点不为0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(treap[u].value&lt;treap[tmp].value) treap[tmp].l=u;  <span class="comment">//将根节点赋为根节点的上继节点的左儿子</span></span><br><span class="line">        <span class="keyword">else</span> treap[tmp].r=u;  <span class="comment">//（同上）右儿子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//根节点的上继节点为0</span></span><br><span class="line">    &#123;</span><br><span class="line">        root=u;  <span class="comment">//u为正式的根节点</span></span><br><span class="line">        <span class="comment">//treap[root].pre=0;  //正式把根节点的上继节点赋为0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码2(无父亲节点域的)：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lturn</span><span class="params">(<span class="keyword">int</span> &amp;k)</span>  <span class="comment">//由于没有父亲域 所以不需要双向改动</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=treap[k].r;  <span class="comment">//tmp即为将来根</span></span><br><span class="line">    treap[k].r=treap[tmp].l;  <span class="comment">//改变目前根的右节点为将来根的左节点</span></span><br><span class="line">    treap[tmp].l=k;  <span class="comment">//改变将来根的左节点为目前根</span></span><br><span class="line">    treap[tmp].size=treap[k].size;  <span class="comment">//更新将来根的节点数</span></span><br><span class="line">    update(k);  <span class="comment">//更新目前根的节点数</span></span><br><span class="line">    k=tmp;  <span class="comment">//改变根</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://s1.ax1x.com/2018/05/11/C0UvxH.png" alt="enter image description here"></p><p><strong><em>右旋</em></strong> (A节点)<br>操作为左旋的镜像</p><ol><li>获取根节点A的<strong>左</strong>儿子节点B</li><li>将节点B的父亲节点信息更新为f （双向）</li><li>将节点A的<strong>左</strong>儿子信息更新为节点B的<strong>右</strong>儿子D （双向）</li><li>将节点B的<strong>右</strong>儿子信息更改为节点A （双向）</li></ol><p>代码1：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RTURN</span><span class="params">(<span class="keyword">int</span> u)</span>  <span class="comment">//右旋 操作同左旋</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    treap[treap[u].pre].l=treap[u].r;</span><br><span class="line">    treap[treap[u].r].pre=treap[u].pre;</span><br><span class="line">    <span class="keyword">int</span> tmp=treap[treap[u].pre].pre;</span><br><span class="line">    treap[u].r=treap[u].pre;</span><br><span class="line">    treap[treap[u].pre].pre=u;</span><br><span class="line">    treap[u].pre=tmp;</span><br><span class="line">    <span class="keyword">if</span>(tmp!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(treap[u].value&lt;treap[tmp].value) treap[tmp].l=u;</span><br><span class="line">        <span class="keyword">else</span> treap[tmp].r=u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        root=u;</span><br><span class="line">        <span class="comment">//treap[root].pre=0;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rturn</span><span class="params">(<span class="keyword">int</span> &amp;k)</span>  <span class="comment">//同理左旋</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=treap[k].l;</span><br><span class="line">    treap[k].l=treap[tmp].r;</span><br><span class="line">    treap[tmp].r=k;</span><br><span class="line">    treap[tmp].size=treap[k].size;</span><br><span class="line">    update(k);</span><br><span class="line">    k=tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2018/05/11/C0aSsA.png" alt="enter image description here"></p><h3 id="模板代码："><a href="#模板代码：" class="headerlink" title="模板代码："></a>模板代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Williams Wu</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,value,rnd,amount,size;</span><br><span class="line">    <span class="comment">//左右儿子 值 随机的优先值 </span></span><br><span class="line">    <span class="comment">//.amount为某个值多次出现的个数 用来代替重复的节点</span></span><br><span class="line">    <span class="comment">//.size为以当前节点为根的子树大小 是查询排名的必备 在删除 旋转 插入时都会改变</span></span><br><span class="line">&#125;;</span><br><span class="line">node treap[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> n,size,root,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;  <span class="comment">//更新结点信息</span></span><br><span class="line">    treap[k].size=treap[treap[k].l].size+treap[treap[k].r].size+treap[k].amount;  </span><br><span class="line">    <span class="comment">//一个节点的路径数等于左右儿子路径数与节点数值重复次数之和</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lturn</span><span class="params">(<span class="keyword">int</span> &amp;k)</span>  <span class="comment">//由于没有父亲域 所以不需要双向改动</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=treap[k].r;  <span class="comment">//tmp即为将来根</span></span><br><span class="line">    treap[k].r=treap[tmp].l;  <span class="comment">//改变目前根的右节点为将来根的左节点</span></span><br><span class="line">    treap[tmp].l=k;  <span class="comment">//改变将来根的左节点为目前根</span></span><br><span class="line">    treap[tmp].size=treap[k].size;  <span class="comment">//更新将来根的节点数</span></span><br><span class="line">    update(k);  <span class="comment">//更新目前根的节点数</span></span><br><span class="line">    k=tmp;  <span class="comment">//改变根</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rturn</span><span class="params">(<span class="keyword">int</span> &amp;k)</span>  <span class="comment">//同理左旋</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=treap[k].l;</span><br><span class="line">    treap[k].l=treap[tmp].r;</span><br><span class="line">    treap[tmp].r=k;</span><br><span class="line">    treap[tmp].size=treap[k].size;</span><br><span class="line">    update(k);</span><br><span class="line">    k=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;k,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        k=++size;</span><br><span class="line">        treap[k].size=treap[k].amount=<span class="number">1</span>;</span><br><span class="line">        treap[k].value=x;</span><br><span class="line">        treap[k].rnd=rand();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;  <span class="comment">//插入叶子结点</span></span><br><span class="line">    treap[k].size++;  <span class="comment">//每经过一个节点，都要先使以它为根的子树的大小增加 1，再递归进入子树查找</span></span><br><span class="line">    <span class="keyword">if</span>(treap[k].value==x)   treap[k].amount++;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;treap[k].value)   <span class="comment">//应在根的右边</span></span><br><span class="line">        &#123;</span><br><span class="line">            insert(treap[k].r,x);  <span class="comment">//继续用根节点的右儿子搜索</span></span><br><span class="line">            <span class="keyword">if</span>(treap[treap[k].r].rnd&lt;treap[k].rnd) lturn(k);  <span class="comment">//维护完二叉搜索树的性质后开始维护堆的性质（旋转）</span></span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                insert(treap[k].l,x);   <span class="comment">//左儿子</span></span><br><span class="line">                <span class="keyword">if</span>(treap[treap[k].l].rnd&lt;treap[k].rnd)rturn(k); <span class="comment">//右旋</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> &amp;k,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span>;  <span class="comment">//已到叶子结点 可以删除 </span></span><br><span class="line">    <span class="keyword">if</span>(treap[k].value==x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(treap[k].amount&gt;<span class="number">1</span>)  <span class="comment">//如果该节点不止一个 重复数量减掉一个即可</span></span><br><span class="line">        &#123;</span><br><span class="line">            treap[k].amount--;</span><br><span class="line">            treap[k].size--;  <span class="comment">//子树大小减1</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(treap[k].l*treap[k].r==<span class="number">0</span>)  k=treap[k].l+treap[k].r; <span class="comment">//如果左右节点中有任何一个是叶子结点 直接替换当前根</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(treap[treap[k].l].rnd&lt;treap[treap[k].r].rnd)  <span class="comment">//左子树的随机值比右子树小</span></span><br><span class="line">            &#123;</span><br><span class="line">                rturn(k);  <span class="comment">//右旋</span></span><br><span class="line">                del(k,x);  <span class="comment">//继续讨论</span></span><br><span class="line">            &#125;</span><br><span class="line">                <span class="keyword">else</span>  <span class="comment">//反之亦然</span></span><br><span class="line">                &#123;</span><br><span class="line">                    lturn(k);</span><br><span class="line">                    del(k,x);</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;treap[k].value)</span><br><span class="line">        &#123;</span><br><span class="line">            treap[k].size--;  </span><br><span class="line">            <span class="comment">//递归返回时要把所有的经过的节点的子树的大小减1。注意 删除前要保证待删除节点存在于树中</span></span><br><span class="line">            del(treap[k].r,x);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                treap[k].size--;</span><br><span class="line">                del(treap[k].l,x);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ranknum</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(treap[k].value==x) <span class="keyword">return</span> treap[treap[k].l].size+<span class="number">1</span>;  <span class="comment">//左子树全部比根小 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;treap[k].value)</span><br><span class="line">            <span class="keyword">return</span> treap[treap[k].l].size+treap[k].amount+ranknum(treap[k].r,x);  <span class="comment">//注意要加上重复的个数</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> ranknum(treap[k].l,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rerank</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"><span class="comment">//根据二叉搜索树的性质 根节点的rank取决于其左子树的大小</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=treap[treap[k].l].size)</span><br><span class="line">        <span class="keyword">return</span> rerank(treap[k].l,x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;treap[treap[k].l].size+treap[k].amount)  <span class="comment">//注意当前节点可能有多个重复的</span></span><br><span class="line">            <span class="keyword">return</span> rerank(treap[k].r,x-treap[treap[k].l].size-treap[k].amount);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> treap[k].value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">provalue</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span>  <span class="comment">//注意定义 小于/不大于</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)<span class="keyword">return</span>;  <span class="comment">//当前节点为空节点 查找结束 最优节点ans即为所求</span></span><br><span class="line">    <span class="keyword">if</span>(treap[k].value&lt;x)  <span class="comment">//当前元素小于目标  </span></span><br><span class="line">    &#123;</span><br><span class="line">        ans=k;  <span class="comment">//更新最优节点</span></span><br><span class="line">        provalue(treap[k].r,x);  <span class="comment">//并访问当前节点的右儿子</span></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">else</span> provalue(treap[k].l,x);  <span class="comment">//不满足条件 访问当前节点的左儿子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nextvalue</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(treap[k].value&gt;x)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=k;</span><br><span class="line">        nextvalue(treap[k].l,x);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">else</span> nextvalue(treap[k].r,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">int</span> opt,x;</span><br><span class="line">    rep(i,<span class="number">1</span>,n)</span><br><span class="line">    &#123;</span><br><span class="line">        read(opt,x);</span><br><span class="line">        <span class="keyword">switch</span>(opt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:insert(root,x); <span class="keyword">break</span>;  <span class="comment">//插入</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:del(root,x); <span class="keyword">break</span>;  <span class="comment">//删除</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ranknum(root,x)); <span class="keyword">break</span>;   <span class="comment">//排名</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,rerank(root,x)); <span class="keyword">break</span>;   <span class="comment">//排名反向</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:ans=<span class="number">0</span>;provalue(root,x); <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,treap[ans].value);<span class="keyword">break</span>;   <span class="comment">//前驱（小于的max）</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:ans=<span class="number">0</span>;nextvalue(root,x); <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,treap[ans].value);<span class="keyword">break</span>;   <span class="comment">//后继（大于的min）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 高级数与结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>高精度</title>
      <link href="/2018/03/01/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
      <url>/2018/03/01/%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
      <content type="html"><![CDATA[<blockquote><p>关键词: 高精度 </p></blockquote><a id="more"></a><h3 id="高精度总结"><a href="#高精度总结" class="headerlink" title="高精度总结"></a>高精度总结</h3><blockquote><p>高精度这种基础知识还是需要复习一下的，所以干脆来总结一下</p></blockquote><h4 id="1-高精度加法"><a href="#1-高精度加法" class="headerlink" title="1.高精度加法"></a>1.高精度加法</h4><p>就是模拟竖式，处理一下进位就好了，需要注意读入的时候用scanf()比较保险，别乱用gets，还有就是加完前导零需要处理。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">头文件省略</span><br><span class="line"><span class="comment">//另一种写法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">char as[11001],bs[11001];</span></span><br><span class="line"><span class="comment">int a[11001],b[11001],c[11002];</span></span><br><span class="line"><span class="comment">int la,lb,lc;</span></span><br><span class="line"><span class="comment">int main()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cle(a); cle(b); cle(c);</span></span><br><span class="line"><span class="comment">scanf("%s%s",as,bs);</span></span><br><span class="line"><span class="comment">la=strlen(as);</span></span><br><span class="line"><span class="comment">lb=strlen(bs);</span></span><br><span class="line"><span class="comment">rep_(i,0,la)  a[i+1]=as[i]-'0';</span></span><br><span class="line"><span class="comment">rep_(i,0,lb)  b[i+1]=bs[i]-'0';</span></span><br><span class="line"><span class="comment">rep(i,1,la/2)  swap(a[i],a[la-i+1]);</span></span><br><span class="line"><span class="comment">rep(i,1,lb/2)  swap(b[i],b[lb-i+1]);</span></span><br><span class="line"><span class="comment">if(la&gt;lb)  lc=la;</span></span><br><span class="line"><span class="comment">else lc=lb;</span></span><br><span class="line"><span class="comment">rep(i,1,lc)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">c[i]=c[i]+a[i]+b[i];</span></span><br><span class="line"><span class="comment">c[i+1]=c[i]/10;</span></span><br><span class="line"><span class="comment">c[i]=c[i]%10;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">if(c[lc+1]&gt;0)  lc+=1;</span></span><br><span class="line"><span class="comment">repf(i,lc,1)  printf("%d",c[i]);</span></span><br><span class="line"><span class="comment">cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> as[<span class="number">1100</span>],bs[<span class="number">1100</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1100</span>],b[<span class="number">1100</span>],c[<span class="number">1100</span>],la,lb,lc,x;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cle(a); cle(b); cle(c);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,as,bs); <span class="comment">//用字符串读入两个加数  warning!!! 别用gets 会莫名爆错</span></span><br><span class="line">    la=<span class="built_in">strlen</span>(as); <span class="comment">//求长度</span></span><br><span class="line">    lb=<span class="built_in">strlen</span>(bs); </span><br><span class="line">    rep_(i,<span class="number">0</span>,la)  a[la-i]=as[i]-<span class="string">'0'</span>;  <span class="comment">//倒序储存</span></span><br><span class="line">    rep_(i,<span class="number">0</span>,lb)  b[lb-i]=bs[i]-<span class="string">'0'</span>;</span><br><span class="line">    lc=<span class="number">1</span>; x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(lc&lt;=la||lc&lt;=lb) <span class="comment">//相当于取两个加数中位数多的那一个</span></span><br><span class="line">    &#123;</span><br><span class="line">        c[lc]=a[lc]+b[lc]+x; <span class="comment">//当前位两数相加再加上上一位的进位</span></span><br><span class="line">        x=c[lc]/<span class="number">10</span>; <span class="comment">//处理当前位的进位</span></span><br><span class="line">        c[lc]%=<span class="number">10</span>; </span><br><span class="line">        lc++; <span class="comment">//下一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    c[lc]=x; <span class="comment">//最后一次进位即为第一位</span></span><br><span class="line">    <span class="keyword">if</span>(c[lc]==<span class="number">0</span>)  lc--; <span class="comment">//处理前导零</span></span><br><span class="line">    repf(i,lc,<span class="number">1</span>)  <span class="built_in">printf</span>(<span class="string">"%d"</span>,c[i]); <span class="comment">//倒序输出</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-高精度减法"><a href="#2-高精度减法" class="headerlink" title="2.高精度减法"></a>2.高精度减法</h4><p>几乎和高精度加法一样，需要判一下减数与被减数的大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> n[<span class="number">1000</span>],n1[<span class="number">1000</span>],n2[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000</span>],b[<span class="number">1000</span>],c[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> la,lb,lc;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cle(a); cle(b); cle(c);  <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,n1,n2);</span><br><span class="line">    la=<span class="built_in">strlen</span>(n1);</span><br><span class="line">    lb=<span class="built_in">strlen</span>(n2);</span><br><span class="line">    <span class="keyword">if</span>(la&lt;lb||(la==lb&amp;&amp;<span class="built_in">strcmp</span>(n1,n2)&lt;<span class="number">0</span>)) <span class="comment">//strcmp为字符串比较函数 此处处理输出负数的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(n,n1);  <span class="comment">//strcpy(a,b) 将b的内容覆盖到a上 此三句相当于交换</span></span><br><span class="line">        <span class="built_in">strcpy</span>(n1,n2);  </span><br><span class="line">        <span class="built_in">strcpy</span>(n2,n);</span><br><span class="line">        swap(la,lb);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"-"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">0</span>,la<span class="number">-1</span>)  a[la-i]=n1[i]-<span class="string">'0'</span>;</span><br><span class="line">    rep(i,<span class="number">0</span>,lb<span class="number">-1</span>)  b[lb-i]=n2[i]-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k&lt;=la||k&lt;=lb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[k]&lt;b[k])</span><br><span class="line">        &#123;</span><br><span class="line">            a[k]+=<span class="number">10</span>;  <span class="comment">//当前位向上一位借1</span></span><br><span class="line">            a[k+<span class="number">1</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        c[k]=a[k]-b[k];  <span class="comment">//当前位减一减</span></span><br><span class="line">        k++;  <span class="comment">//处理下一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    lc=k;  <span class="comment">//长度</span></span><br><span class="line">    <span class="keyword">while</span>((c[lc]==<span class="number">0</span>)&amp;&amp;(lc&gt;<span class="number">1</span>)) lc--; <span class="comment">//别忘了前导零</span></span><br><span class="line">    repf(i,lc,<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d"</span>,c[i]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-高精度乘法"><a href="#3-高精度乘法" class="headerlink" title="3.高精度乘法"></a>3.高精度乘法</h4><p>这个就要比前两个有难度了，因为竖式算乘法本身就模拟了第一个乘数乘以第二个乘数拆开来的各个位，而我们要做的就是倒序状态下模拟这个过程（其实把两个乘数都拆开了），简单地试一下后会发现乘积的i+j-1位即是第一个乘数第i位与第二个乘数第j位的乘积，然后就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> as[<span class="number">1100</span>],bs[<span class="number">1100</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1100</span>],b[<span class="number">1100</span>],c[<span class="number">1100</span>];</span><br><span class="line"><span class="keyword">int</span> la,lb,lc,x;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cle(a); cle(b); cle(c);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,as,bs);</span><br><span class="line">    la=<span class="built_in">strlen</span>(as);</span><br><span class="line">    lb=<span class="built_in">strlen</span>(bs);</span><br><span class="line">    rep_(i,<span class="number">0</span>,la) a[la-i]=as[i]-<span class="string">'0'</span>;</span><br><span class="line">    rep_(i,<span class="number">0</span>,lb) b[lb-i]=bs[i]-<span class="string">'0'</span>;</span><br><span class="line">  rep(i,<span class="number">1</span>,la)</span><br><span class="line">&#123;</span><br><span class="line">     x=<span class="number">0</span>;</span><br><span class="line">     rep(j,<span class="number">1</span>,lb) <span class="comment">//处理乘数的每一位</span></span><br><span class="line">     &#123;</span><br><span class="line">   c[i+j<span class="number">-1</span>]=a[i]*b[j]+x+c[i+j<span class="number">-1</span>];  <span class="comment">//当前位相乘+进位+乘积已有位上的数</span></span><br><span class="line">   x=c[i+j<span class="number">-1</span>]/<span class="number">10</span>;</span><br><span class="line">   c[i+j<span class="number">-1</span>]%=<span class="number">10</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     c[i+lb]=x;  <span class="comment">//进位</span></span><br><span class="line">&#125;</span><br><span class="line">lc=la+lb;</span><br><span class="line"><span class="keyword">while</span>(c[lc]==<span class="number">0</span>&amp;&amp;lc&gt;<span class="number">1</span>)  lc--;  <span class="comment">//删除前导0</span></span><br><span class="line">repf(i,lc,<span class="number">1</span>)  <span class="built_in">printf</span>(<span class="string">"%d"</span>,c[i]);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-高精度除法"><a href="#4-高精度除法" class="headerlink" title="4.高精度除法"></a>4.高精度除法</h4><p>坑先占着 这东西太烦 原来写的也找不到了 不写了</p>]]></content>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>头文件</title>
      <link href="/2018/02/27/%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
      <url>/2018/02/27/%E5%A4%B4%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<blockquote><p>关键词: 头文件</p></blockquote><a id="more"></a><h3 id="头文件总结"><a href="#头文件总结" class="headerlink" title="头文件总结"></a>头文件总结</h3><blockquote><p>头文件这种东西，偷一下就行了对吧</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Williams Wu</span></span><br><span class="line"><span class="comment">/*#include &lt;EGE.h&gt;  //绘图头文件</span></span><br><span class="line"><span class="comment">#define SHOW_CONSOLE*/</span></span><br><span class="line"><span class="comment">/*#include &lt;cstdio&gt; //定义输入/输出函数</span></span><br><span class="line"><span class="comment">#include &lt;iostream&gt; //数据流输入/输出</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt; //STL通用算法</span></span><br><span class="line"><span class="comment">#include &lt;cmath&gt; //定义数学函数</span></span><br><span class="line"><span class="comment">#include &lt;cstdlib&gt; //定义杂项函数及内存分配函数</span></span><br><span class="line"><span class="comment">#include &lt;cstring&gt; //字符串处理</span></span><br><span class="line"><span class="comment">#include &lt;string&gt; //字符串类</span></span><br><span class="line"><span class="comment">#include &lt;ctime&gt; //定义关于时间的函数*/</span></span><br><span class="line"><span class="comment">/*#include &lt;bitset&gt; //STL位集容器</span></span><br><span class="line"><span class="comment">#include &lt;cstype&gt; //字符处理</span></span><br><span class="line"><span class="comment">#include &lt;cerrno&gt; //定义错误码</span></span><br><span class="line"><span class="comment">#include &lt;complex&gt; //复数类</span></span><br><span class="line"><span class="comment">#include &lt;clocale&gt; //定义本地化函数</span></span><br><span class="line"><span class="comment">#include &lt;deque&gt; //STL双端队列容器</span></span><br><span class="line"><span class="comment">#include &lt;exception&gt; //异常处理类</span></span><br><span class="line"><span class="comment">#include &lt;fstream&gt; //文件输入/输出</span></span><br><span class="line"><span class="comment">#include &lt;functional&gt; //STL定义运算函数(代替运算符)</span></span><br><span class="line"><span class="comment">#include &lt;limits&gt; //定义各种数据类型最值常量</span></span><br><span class="line"><span class="comment">#include &lt;list&gt; //STL线性列表容器</span></span><br><span class="line"><span class="comment">#include &lt;map&gt; //STL映射容器</span></span><br><span class="line"><span class="comment">#include &lt;iomanip&gt; //参数化输入/输出</span></span><br><span class="line"><span class="comment">#include &lt;ios&gt; //基本输入/输出支持</span></span><br><span class="line"><span class="comment">#include &lt;iosfwd&gt; //输入/输出系统使用的前置声明</span></span><br><span class="line"><span class="comment">#include &lt;istream&gt; //基本输入流</span></span><br><span class="line"><span class="comment">#include &lt;ostream&gt; //基本输出流</span></span><br><span class="line"><span class="comment">#include &lt;queue&gt; //STL队列容器</span></span><br><span class="line"><span class="comment">#include &lt;set&gt; //STL集合容器</span></span><br><span class="line"><span class="comment">#include &lt;sstream&gt; //基于字符串的流</span></span><br><span class="line"><span class="comment">#include &lt;stack&gt; //STL堆栈容器</span></span><br><span class="line"><span class="comment">#include &lt;stdexcept&gt; //标准异常类</span></span><br><span class="line"><span class="comment">#include &lt;streambuf&gt; //底层输入/输出支持</span></span><br><span class="line"><span class="comment">#include &lt;utility&gt; //STL通用模板类</span></span><br><span class="line"><span class="comment">#include &lt;vector&gt; //STL动态数组容器</span></span><br><span class="line"><span class="comment">#include &lt;cwchar.h&gt;//宽字符处理及输入/输出</span></span><br><span class="line"><span class="comment">#include &lt;cwctype.h&gt; //宽字符分类*/</span></span><br></pre></td></tr></table></figure><p>上面一部分是分开来的各类头文件，如果想偷懒的的可以使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(x,y,z) for (int x=(y);(x)&lt;=(z);(x)++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep_(x,y,z) for (int x=(y);(x)&lt;(z);(x)++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repf(x,y,z) for (int x=(y);(x)&gt;=(z);(x)--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repf_(x,y,z) for (int x=(y);(x)&gt;(z);(x)--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f  <span class="comment">//0x7fffffff</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clemin(x) memset(x,-1,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clemax(x) memset(x,0x3f,sizeof(x))  <span class="comment">//127</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br></pre></td></tr></table></figure><p>这一部分是各种宏定义，方便写程序，注意cle(x)表示清零，clemin()表示清成-1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const double PI =3.14159265358979323846264338327950288419716939937510;</span><br><span class="line">const double e=2.7182818284590452353602874713526624977572470936999596;</span><br><span class="line">const double eps = 0.000000001;</span><br></pre></td></tr></table></figure><p>定义一些常数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&gt;y?x:y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&lt;y?x:y;&#125;</span><br></pre></td></tr></table></figure><p>自己定义min和max，可以跑得快一点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////optimize//////////////////////////</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize("O2") //O2优化 </span></span><br><span class="line"><span class="comment">//#pragma GCC optimize("Ofast") //Ofast优化 </span></span><br><span class="line"><span class="comment">//ios::sync_with_stdio(false); //取消同步(加快流输入输出速度)</span></span><br></pre></td></tr></table></figure><p>Ofast和O2优化，还有取消同步 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////read///////////////////////////</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span></span>&#123;<span class="keyword">char</span> ch;x=<span class="number">0</span>;<span class="keyword">bool</span> flag=<span class="literal">false</span>;ch=getchar();<span class="keyword">while</span> (ch&gt;<span class="string">'9'</span>||ch&lt;<span class="string">'0'</span>)&#123;<span class="keyword">if</span> (ch==<span class="string">'-'</span>)flag=<span class="literal">true</span>;ch=getchar();&#125;<span class="keyword">while</span> ((ch&lt;=<span class="string">'9'</span>&amp;&amp;ch&gt;=<span class="string">'0'</span>)) &#123;x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>;ch=getchar();&#125;<span class="keyword">if</span>(flag)x*=<span class="number">-1</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x, T&amp; y)</span></span>&#123;read(x);read(y);&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x, T&amp; y, T&amp; z)</span></span>&#123;read(x);read(y);read(z);&#125;</span><br></pre></td></tr></table></figure><p>读入优化 为了偷懒还设置了可以一次读入2、3个的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/////////////////variables&amp;functions/////////////////////</span></span><br><span class="line">__attribute__((optimize(<span class="string">"Ofast"</span>),target(<span class="string">"no-ieee-fp,arch=amdfam10"</span>)))<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">xxx</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于加在int main前的那句话<br>我也不知道是干啥的<br>但是听一位大（基）佬说可以玄学优化<br>那就加上了呗!</p>]]></content>
      
      
        <tags>
            
            <tag> 头文件 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
